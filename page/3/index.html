<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>晓江南的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="blog.xiaojn.cn">
<meta property="og:type" content="website">
<meta property="og:title" content="晓江南的博客">
<meta property="og:url" content="https://evanqiao.github.io/xiaojn-blog/page/3/index.html">
<meta property="og:site_name" content="晓江南的博客">
<meta property="og:description" content="blog.xiaojn.cn">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="晓江南的博客">
<meta name="twitter:description" content="blog.xiaojn.cn">
  
    <link rel="alternate" href="/atom.xml" title="晓江南的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/xiaojn-blog/css/style.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  

</head>
</html>
<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/xiaojn-blog/" id="logo">晓江南的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/xiaojn-blog/" id="subtitle">Hope is a good thing!</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/xiaojn-blog/">Home</a>
        
          <a class="main-nav-link" href="/xiaojn-blog/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://evanqiao.github.io/xiaojn-blog"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-C++中各种类型的数据所占内存的大小" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/xiaojn-blog/2017/04/16/C++中各种类型的数据所占内存的大小/" class="article-date">
  <time datetime="2017-04-16T13:57:36.000Z" itemprop="datePublished">2017-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/xiaojn-blog/categories/编程语言/">编程语言</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/xiaojn-blog/2017/04/16/C++中各种类型的数据所占内存的大小/">C++中各种类型的数据所占内存的大小</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="基本类型占空间的大小"><a href="#基本类型占空间的大小" class="headerlink" title="基本类型占空间的大小"></a>基本类型占空间的大小</h2><p>直接上例子：测试环境是64位机上。<strong>以下测试都在64位机上进行。</strong><br>32位机上，只有指针类型是4字节的，其他的基本类型和64位机上一样。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  sz(A) sizeof(A)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"sz(int) = "</span> &lt;&lt; sz(<span class="keyword">int</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"sz(long) = "</span> &lt;&lt; sz(<span class="keyword">long</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"sz(long long) = "</span> &lt;&lt; sz(<span class="keyword">long</span> <span class="keyword">long</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"sz(float) = "</span> &lt;&lt; sz(<span class="keyword">float</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"sz(double) = "</span> &lt;&lt; sz(<span class="keyword">double</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"sz(long double) = "</span> &lt;&lt; sz(<span class="keyword">long</span> <span class="keyword">double</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"sz(char *) = "</span> &lt;&lt; sz(<span class="keyword">char</span> *) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    sz(int) = 4</span></span><br><span class="line"><span class="comment">    sz(long) = 4</span></span><br><span class="line"><span class="comment">    sz(long long) = 8</span></span><br><span class="line"><span class="comment">    sz(float) = 4</span></span><br><span class="line"><span class="comment">    sz(double) = 8</span></span><br><span class="line"><span class="comment">    sz(long double) = 16</span></span><br><span class="line"><span class="comment">    sz(char *) = 8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="枚举类型和共用体类型占空间大小"><a href="#枚举类型和共用体类型占空间大小" class="headerlink" title="枚举类型和共用体类型占空间大小"></a>枚举类型和共用体类型占空间大小</h2><p>枚举类型所占的空间是4字节。共用体中的所有成员共用的是同一段内存，共用体中的成员的偏移量也都一样，union所占的内存大小是最长的成员所占内存的大小，同时也要考虑到字节对齐，字节对齐遵循的原则是union变量的大小需要是最长成员(基本类型)大小的整数倍。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  sz(A) sizeof(A)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">        a = <span class="number">1</span>,</span><br><span class="line">        b = <span class="number">2</span>,</span><br><span class="line">        m = <span class="number">3</span>,</span><br><span class="line">        ch = <span class="string">'a'</span></span><br><span class="line">    &#125;_enum_A;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">char</span> <span class="built_in">array</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">char</span> *p;</span><br><span class="line">    &#125;_union_U;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"sz(_enum_A) = "</span> &lt;&lt; sz(_enum_A) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"sz(_union_U) = "</span> &lt;&lt; sz(_union_U) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (<span class="keyword">char</span> *)&amp;_union_U.p - (<span class="keyword">char</span> *)&amp;_union_U);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sz(_enum_A) = 4</span></span><br><span class="line"><span class="comment">sz(_union_U) = 16</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="类所占空间的大小"><a href="#类所占空间的大小" class="headerlink" title="类所占空间的大小"></a>类所占空间的大小</h2><p>类中的函数不占空间，函数在代码区存放。如果一个类只含有函数(非虚函数)，这个类占的内存大小是1，如果含有虚函数，就需要存放虚表指针，占用的空间是指针所占空间的大小。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  sz(A) sizeof(A)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"sz(A) = "</span> &lt;&lt; sz(A) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"sz(B) = "</span> &lt;&lt; sz(B) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sz(A) = 1</span></span><br><span class="line"><span class="comment">sz(B) = 8</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>分析一下类所占内存大小和类中成员的偏移量。<br>两点原则：</p>
<ul>
<li>成员的偏移量是该成员所占字节的整数倍，如果成员是结构体的话，那就是结构体中最长的基本类型所占字节的整数倍</li>
<li>类或结构体的总大小需要是类或结构体中最长的基本类型所占字节的整数倍</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">union</span> U &#123;</span><br><span class="line">        <span class="keyword">char</span> buff[<span class="number">13</span>];</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">    &#125;u;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">double</span> ld;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;    &#125;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">char</span>* (*f)(<span class="keyword">void</span>*);</span><br><span class="line">    <span class="keyword">enum</span>&#123;red, green, blue&#125; color;</span><br><span class="line">&#125; base;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"sz(base) = "</span> &lt;&lt; sz(base) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The offset of ld is "</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (<span class="keyword">char</span> *)&amp;base.ld - (<span class="keyword">char</span> *)&amp;base);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The offset of u is "</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (<span class="keyword">char</span> *)&amp;base.u - (<span class="keyword">char</span> *)&amp;base);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sz(base) = 64</span></span><br><span class="line"><span class="comment">The offset of ld is 32</span></span><br><span class="line"><span class="comment">The offset of u is 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/sizeof.png" alt="base对象占用空间布局"></p>
<p>全局变量和静态变量的存储是放在一块的，在程序编译时分配。局部类中不能包含静态变量，而全局类中可以包含静态变量，如果类中含有静态变量时，在用sizeof去统计类的大小时，静态变量不包含在内。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AA</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> si;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> abc;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125;s;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sz(AA) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://evanqiao.github.io/xiaojn-blog/2017/04/16/C++中各种类型的数据所占内存的大小/" data-id="cjxbtu1mr0000qo67se8kgni6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/xiaojn-blog/tags/C/">C++</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-C++和Java中字符串与数字的相互转换" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/xiaojn-blog/2017/04/09/C++和Java中字符串与数字的相互转换/" class="article-date">
  <time datetime="2017-04-09T14:31:36.000Z" itemprop="datePublished">2017-04-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/xiaojn-blog/categories/算法/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/xiaojn-blog/2017/04/09/C++和Java中字符串与数字的相互转换/">C++和Java中字符串与数字的相互转换</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="快速参考"><a href="#快速参考" class="headerlink" title="快速参考"></a>快速参考</h2><p><strong>数字转字符串：</strong><br>C++</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">方法<span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">( <span class="keyword">char</span>* buffer, <span class="keyword">const</span> <span class="keyword">char</span>* format, ... )</span></span>;</span><br><span class="line"></span><br><span class="line">方法<span class="number">2</span>)</span><br><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">ostringstream</span> <span class="title">out</span><span class="params">(<span class="string">"1 2"</span>)</span></span>;</span><br><span class="line">out &lt;&lt; <span class="number">3</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; out.str() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">方法<span class="number">3</span>）</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">100</span>;  <span class="keyword">double</span> d = <span class="number">-10.02</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; to_string(a) &lt;&lt; <span class="string">" "</span> &lt;&lt; to_string(d) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">方法<span class="number">4</span>）</span><br><span class="line"><span class="function"><span class="keyword">char</span> *  <span class="title">itoa</span> <span class="params">( <span class="keyword">int</span> value, <span class="keyword">char</span> * str, <span class="keyword">int</span> base )</span></span>;</span><br><span class="line">不推荐使用</span><br></pre></td></tr></table></figure>

<p>Java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String s1 = Integer.toString(a, <span class="number">10</span>);</span><br><span class="line">String s2 = Float.toString(f);</span><br><span class="line">String s3 = Float.toHexString(f);</span><br><span class="line">String s4 = Double.toString(d);</span><br><span class="line">String s5 = Character.toString(c);</span><br><span class="line">String s1 = String.valueOf(a);</span><br><span class="line">String s2 = String.valueOf(f);</span><br><span class="line">String s3 = String.valueOf(d);</span><br><span class="line">String s4 = String.valueOf(c);</span><br><span class="line">String s5 = String.valueOf(arr);</span><br></pre></td></tr></table></figure>

<p><strong>字符串转数字：</strong><br>C++</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">方法<span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sscanf</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span>* buffer, <span class="keyword">const</span> <span class="keyword">char</span>* format, ... )</span></span>; </span><br><span class="line"></span><br><span class="line">方法<span class="number">2</span>)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">istringstream</span> in;  <span class="comment">// could also use in("1 2")</span></span><br><span class="line">in.str(<span class="string">"1 2"</span>);</span><br><span class="line">in &gt;&gt; n;  <span class="comment">// n = 1</span></span><br><span class="line"></span><br><span class="line">方法<span class="number">3</span>）</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stoi</span><span class="params">( <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str, <span class="built_in">std</span>::<span class="keyword">size_t</span>* pos = <span class="number">0</span>, <span class="keyword">int</span> base = <span class="number">10</span> )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">stof</span><span class="params">( <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str, <span class="built_in">std</span>::<span class="keyword">size_t</span>* pos = <span class="number">0</span> )</span></span>;</span><br><span class="line"></span><br><span class="line">方法<span class="number">4</span>）</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atoi</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *str )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">atof</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *str )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">strtol</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">char</span> **str_end, <span class="keyword">int</span> base )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">strtof</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">char</span>** str_end )</span></span>;  (since C++<span class="number">11</span>)</span><br></pre></td></tr></table></figure>

<p>Java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = Integer.parseInt(s1, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">float</span> f = Float.parseFloat(s2);</span><br><span class="line"><span class="keyword">double</span> d = Double.parseDouble(s3);</span><br></pre></td></tr></table></figure>

<h2 id="数字转字符串"><a href="#数字转字符串" class="headerlink" title="数字转字符串"></a>数字转字符串</h2><h3 id="C-中如何把数字转换为字符串"><a href="#C-中如何把数字转换为字符串" class="headerlink" title="C++中如何把数字转换为字符串"></a>C++中如何把数字转换为字符串</h3><ol>
<li>用<code>sprintf</code>函数</li>
<li>用<code>ostreamstring</code>对象</li>
<li>用<code>to_string</code>函数</li>
<li>用<code>itoa</code>函数</li>
</ol>
<h4 id="用sprintf函数"><a href="#用sprintf函数" class="headerlink" title="用sprintf函数"></a>用<code>sprintf</code>函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">printf</span>, <span class="built_in">std</span>::<span class="built_in">fprintf</span>, <span class="built_in">std</span>::<span class="built_in">sprintf</span>, <span class="built_in">std</span>::<span class="built_in">snprintf</span></span><br><span class="line">Defined in header &lt;cstdio&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span>* format, ... )</span></span>;  (<span class="number">1</span>)	</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fprintf</span><span class="params">( <span class="built_in">std</span>::FILE* stream, <span class="keyword">const</span> <span class="keyword">char</span>* format, ... )</span></span>;  (<span class="number">2</span>)	</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">( <span class="keyword">char</span>* buffer, <span class="keyword">const</span> <span class="keyword">char</span>* format, ... )</span></span>;  (<span class="number">3</span>)	</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snprintf</span><span class="params">( <span class="keyword">char</span>* buffer, <span class="built_in">std</span>::<span class="keyword">size_t</span> buf_size, <span class="keyword">const</span> <span class="keyword">char</span>* format, ... )</span></span>;  (<span class="number">4</span>)	(since C++<span class="number">11</span>)</span><br></pre></td></tr></table></figure>

<p>从给定位置加载数据，将它们转换为字符串等效项，并将结果写入各种接收器。<br>1) Writes the results to stdout.<br>2) Writes the results to a file stream stream.<br>3) Writes the results to a character string buffer.<br>4) Writes the results to a character string buffer. At most <code>buf_size - 1</code> characters are written. The resulting character string will be terminated with a null character, unless <code>buf_size</code> is zero. If <code>buf_size</code> is zero, nothing is written and buffer may be a null pointer, however the return value (number of bytes that would be written) is still calculated and returned.<br>If a call to sprintf or snprintf causes copying to take place between objects that overlap, the behavior is undefined.</p>
<p><strong>Parameters</strong><br><strong>stream</strong>        -    output file stream to write to<br><strong>buffer</strong>        -    pointer to a character string to write to<br><strong>buf_size</strong>    -    up to <code>buf_size - 1</code> characters may be written, plus the null terminator<br><strong>format</strong>        -    pointer to a null-terminated multibyte string specifying how to interpret the data. The format string consists of ordinary multibyte characters (except %), which are copied unchanged into the output stream, and conversion specifications.</p>
<p><strong>Return value</strong><br>1-2) Number of characters written if successful or a negative value if an error occurred.<br>3) Number of characters written if successful (not including the terminating null character) or a negative value if an error occurred.<br>4) Number of characters that would have been written for a sufficiently large buffer if successful (not including the terminating null character), or a negative value if an error occurred. Thus, the (null-terminated) output has been completely written if and only if the returned value is nonnegative and less than buf_size.</p>
<hr>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cinttypes&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">printf</span>(<span class="string">"Strings:\n"</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* s = <span class="string">"Hello"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">printf</span>(<span class="string">"\t[%10s]\n\t[%-10s]\n\t[%*s]\n\t[%-10.*s]\n\t[%-*.*s]\n"</span>,</span><br><span class="line">        s, s, <span class="number">10</span>, s, <span class="number">4</span>, s, <span class="number">10</span>, <span class="number">4</span>, s);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">printf</span>(<span class="string">"Characters:\t%c %%\n"</span>, <span class="number">65</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">printf</span>(<span class="string">"Integers\n"</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">printf</span>(<span class="string">"Decimal:\t%i %d %.6i %i %.0i %+i %u\n"</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">printf</span>(<span class="string">"Hexadecimal:\t%x %x %X %#x\n"</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">printf</span>(<span class="string">"Octal:\t%o %#o %#o\n"</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">4</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">printf</span>(<span class="string">"Floating point\n"</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">printf</span>(<span class="string">"Rounding:\t%f %.0f %.32f\n"</span>, <span class="number">1.5</span>, <span class="number">1.5</span>, <span class="number">1.5</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">printf</span>(<span class="string">"Padding:\t%05.2f %.2f %5.2f\n"</span>, <span class="number">1.5</span>, <span class="number">1.5</span>, <span class="number">1.5</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">printf</span>(<span class="string">"Scientific:\t%E %e\n"</span>, <span class="number">1.5</span>, <span class="number">1.5</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">printf</span>(<span class="string">"Hexadecimal:\t%a %A\n"</span>, <span class="number">1.5</span>, <span class="number">1.5</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">printf</span>(<span class="string">"Special values:\t0/0=%g 1/0=%g\n"</span>, <span class="number">0.0</span>/<span class="number">0.0</span>, <span class="number">1.0</span>/<span class="number">0.0</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">printf</span>(<span class="string">"Variable width control:\n"</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">printf</span>(<span class="string">"right-justified variable width: '%*c'\n"</span>, <span class="number">5</span>, <span class="string">'x'</span>);</span><br><span class="line">    <span class="keyword">int</span> r = <span class="built_in">std</span>::<span class="built_in">printf</span>(<span class="string">"left-justified variable width : '%*c'\n"</span>, <span class="number">-5</span>, <span class="string">'x'</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">printf</span>(<span class="string">"(the last printf printed %d characters)\n"</span>, r);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// fixed-width types</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">uint32_t</span> val = <span class="built_in">std</span>::numeric_limits&lt;<span class="built_in">std</span>::<span class="keyword">uint32_t</span>&gt;::max();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">printf</span>(<span class="string">"Largest 32-bit value is %"</span> PRIu32 <span class="string">" or %#"</span> PRIx32 <span class="string">"\n"</span>, val, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Strings:</span><br><span class="line">        [     Hello]</span><br><span class="line">        [Hello     ]</span><br><span class="line">        [     Hello]</span><br><span class="line">        [Hell      ]</span><br><span class="line">        [Hell      ]</span><br><span class="line">Characters:     A %</span><br><span class="line">Integers</span><br><span class="line">Decimal:        1 2 000003 0  +4 4294967295</span><br><span class="line">Hexadecimal:    5 a A 0x6</span><br><span class="line">Octal:  12 012 04</span><br><span class="line">Floating point</span><br><span class="line">Rounding:       1.500000 2 1.30000000000000004440892098500626</span><br><span class="line">Padding:        01.50 1.50  1.50</span><br><span class="line">Scientific:     1.500000E+00 1.500000e+00</span><br><span class="line">Hexadecimal:    0x1.8p+0 0X1.8P+0</span><br><span class="line">Special values: 0/0=nan 1/0=inf</span><br><span class="line">Variable width control:</span><br><span class="line">right-justified variable width: &apos;    x&apos;</span><br><span class="line">left-justified variable width : &apos;x    &apos;</span><br><span class="line">(the last printf printed 40 characters)</span><br><span class="line">Largest 32-bit value is 4294967295 or 0xffffffff</span><br></pre></td></tr></table></figure>

<p>详见：<a href="http://en.cppreference.com/w/cpp/io/c/fprintf" target="_blank" rel="noopener">http://en.cppreference.com/w/cpp/io/c/fprintf</a></p>
<h4 id="用ostreamstring对象"><a href="#用ostreamstring对象" class="headerlink" title="用ostreamstring对象"></a>用<code>ostreamstring</code>对象</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">istringstream</span> in;  <span class="comment">// could also use in("1 2")</span></span><br><span class="line">    in.str(<span class="string">"1 2"</span>);</span><br><span class="line">    in &gt;&gt; n;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"after reading the first int from \"1 2\", the int is "</span></span><br><span class="line">              &lt;&lt; n &lt;&lt; <span class="string">", str() = \""</span> &lt;&lt; in.str() &lt;&lt; <span class="string">"\"\n"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">ostringstream</span> <span class="title">out</span><span class="params">(<span class="string">"1 2"</span>)</span></span>;</span><br><span class="line">    out &lt;&lt; <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"after writing the int '3' to output stream \"1 2\""</span></span><br><span class="line">              &lt;&lt; <span class="string">", str() = \""</span> &lt;&lt; out.str() &lt;&lt; <span class="string">"\"\n"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">ostringstream</span> <span class="title">ate</span><span class="params">(<span class="string">"1 2"</span>, <span class="built_in">std</span>::ios_base::ate)</span></span>;</span><br><span class="line">    ate &lt;&lt; <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"after writing the int '3' to append stream \"1 2\""</span></span><br><span class="line">              &lt;&lt; <span class="string">", str() = \""</span> &lt;&lt; ate.str() &lt;&lt; <span class="string">"\"\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Output:</span><br><span class="line">after reading the first int from &quot;1 2&quot;, the int is 1, str() = &quot;1 2&quot;</span><br><span class="line">after writing the int &apos;3&apos; to output stream &quot;1 2&quot;, str() = &quot;3 2&quot;</span><br><span class="line">after writing the int &apos;3&apos; to append stream &quot;1 2&quot;, str() = &quot;1 23&quot;</span><br></pre></td></tr></table></figure>

<p>打开输入输出流的方式：</p>
<table>
<thead>
<tr>
<th align="left">Constant</th>
<th align="left">Explanation</th>
</tr>
</thead>
<tbody><tr>
<td align="left">app</td>
<td align="left">seek to the end of stream before each write</td>
</tr>
<tr>
<td align="left">binary</td>
<td align="left">open in binary mode</td>
</tr>
<tr>
<td align="left">in</td>
<td align="left">open for reading</td>
</tr>
<tr>
<td align="left">out</td>
<td align="left">open for writing</td>
</tr>
<tr>
<td align="left">trunc</td>
<td align="left">discard the contents of the stream when opening</td>
</tr>
<tr>
<td align="left">ate</td>
<td align="left">seek to the end of stream immediately after open</td>
</tr>
</tbody></table>
<h4 id="用to-string函数"><a href="#用to-string函数" class="headerlink" title="用to_string函数"></a>用<code>to_string</code>函数</h4><p><code>to_string</code>函数是C++11标准引入的，它可以把int,long,double,long long等数据类型的变量转换成string类型，<code>to_string</code>函数定义在头文件<code>&lt;string&gt;</code>中，把数字转变为string类型和直接用<code>std::cout</code>打印出来的效果略有差别，具体看下面的例子。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> f = <span class="number">23.43</span>;</span><br><span class="line">    <span class="keyword">double</span> f2 = <span class="number">1e-9</span>;</span><br><span class="line">    <span class="keyword">double</span> f3 = <span class="number">1e40</span>;</span><br><span class="line">    <span class="keyword">double</span> f4 = <span class="number">1e-40</span>;</span><br><span class="line">    <span class="keyword">double</span> f5 = <span class="number">123456789</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> f_str = <span class="built_in">std</span>::to_string(f);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> f_str2 = <span class="built_in">std</span>::to_string(f2); <span class="comment">// Note: returns "0.000000"</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> f_str3 = <span class="built_in">std</span>::to_string(f3); <span class="comment">// Note: Does not return "1e+40".</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> f_str4 = <span class="built_in">std</span>::to_string(f4); <span class="comment">// Note: returns "0.000000"</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> f_str5 = <span class="built_in">std</span>::to_string(f5);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"std::cout: "</span> &lt;&lt; f &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">              &lt;&lt; <span class="string">"to_string: "</span> &lt;&lt; f_str  &lt;&lt; <span class="string">"\n\n"</span></span><br><span class="line">              &lt;&lt; <span class="string">"std::cout: "</span> &lt;&lt; f2 &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">              &lt;&lt; <span class="string">"to_string: "</span> &lt;&lt; f_str2 &lt;&lt; <span class="string">"\n\n"</span></span><br><span class="line">              &lt;&lt; <span class="string">"std::cout: "</span> &lt;&lt; f3 &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">              &lt;&lt; <span class="string">"to_string: "</span> &lt;&lt; f_str3 &lt;&lt; <span class="string">"\n\n"</span></span><br><span class="line">              &lt;&lt; <span class="string">"std::cout: "</span> &lt;&lt; f4 &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">              &lt;&lt; <span class="string">"to_string: "</span> &lt;&lt; f_str4 &lt;&lt; <span class="string">"\n\n"</span></span><br><span class="line">              &lt;&lt; <span class="string">"std::cout: "</span> &lt;&lt; f5 &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">              &lt;&lt; <span class="string">"to_string: "</span> &lt;&lt; f_str5 &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">-100</span>;</span><br><span class="line">    <span class="keyword">float</span> b = <span class="number">-012.00</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; to_string(a) &lt;&lt; <span class="string">" "</span> &lt;&lt; to_string(b) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Output:</span><br><span class="line">std::cout: 23.43</span><br><span class="line">to_string: 23.430000</span><br><span class="line"></span><br><span class="line">std::cout: 1e-09</span><br><span class="line">to_string: 0.000000</span><br><span class="line"></span><br><span class="line">std::cout: 1e+40</span><br><span class="line">to_string: 10000000000000000303786028427003666890752.000000</span><br><span class="line"></span><br><span class="line">std::cout: 1e-40</span><br><span class="line">to_string: 0.000000</span><br><span class="line"></span><br><span class="line">std::cout: 1.23457e+08</span><br><span class="line">to_string: 123456789.000000</span><br><span class="line">-100 12.000000</span><br></pre></td></tr></table></figure>

<h4 id="用itoa函数"><a href="#用itoa函数" class="headerlink" title="用itoa函数"></a>用<code>itoa</code>函数</h4><p>函数原型为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char *  itoa ( int value, char * str, int base );</span><br></pre></td></tr></table></figure>

<p>该函数会把<code>value</code>按照<code>base</code>进制转换成字符串并存放在<code>str</code>所指向的内存单元中，返回值是一个以<code>null</code>结尾的字符串，和参数<code>str</code>一样。该函数没有在<strong>ANSI-C</strong>中定义，也不是C++的一部分，但是一些编译器支持这样使用，定义在头文件<code>&lt;stdlib.h&gt;</code>中。<br>既然有这么多选择，所以不推荐使用此函数，该函数的可移植性比较差。</p>
<h3 id="C-中如何把字符串转换为数字"><a href="#C-中如何把字符串转换为数字" class="headerlink" title="C++中如何把字符串转换为数字"></a>C++中如何把字符串转换为数字</h3><ol>
<li>用<code>sscanf</code>函数</li>
<li>用<code>istreamstring</code>对象</li>
<li>用<code>stoi</code> <code>stof</code> <code>stod</code>函数</li>
<li>用<code>atoi</code> <code>atof</code> <code>strtof</code>函数</li>
</ol>
<h4 id="用sscanf函数"><a href="#用sscanf函数" class="headerlink" title="用sscanf函数"></a>用<code>sscanf</code>函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">scanf</span>, <span class="built_in">std</span>::<span class="built_in">fscanf</span>, <span class="built_in">std</span>::<span class="built_in">sscanf</span></span><br><span class="line">Defined in header &lt;cstdio&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">scanf</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span>* format, ... )</span></span>;​  (<span class="number">1</span>)	</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fscanf</span><span class="params">( <span class="built_in">std</span>::FILE* stream, <span class="keyword">const</span> <span class="keyword">char</span>* format, ... )</span></span>;  (<span class="number">2</span>)	</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sscanf</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span>* buffer, <span class="keyword">const</span> <span class="keyword">char</span>* format, ... )</span></span>;  (<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Reads data from the a variety of sources, interprets it according to format and stores the results into given locations.<br>1) Reads the data from stdin<br>2) Reads the data from file stream stream<br>3) Reads the data from null-terminated character string buffer<br><strong>Return value:</strong><br>Number of receiving arguments successfully assigned (which may be zero in case a matching failure occurred before the first receiving argument was assigned), or EOF if input failure occurs before the first receiving argument was assigned.</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;clocale&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">float</span> x, y;</span><br><span class="line">    <span class="keyword">char</span> str1[<span class="number">10</span>], str2[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">wchar_t</span> warr[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">std</span>::setlocale(LC_ALL, <span class="string">"en_US.utf8"</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">char</span> input[] = <span class="string">u8"25 54.32E-1 Thompson 56789 0123 56ß水"</span>;</span><br><span class="line">    <span class="comment">// parse as follows:</span></span><br><span class="line">    <span class="comment">// %d: an integer </span></span><br><span class="line">    <span class="comment">// %f: a floating-point value</span></span><br><span class="line">    <span class="comment">// %9s: a string of at most 9 non-whitespace characters</span></span><br><span class="line">    <span class="comment">// %2d: two-digit integer (digits 5 and 6)</span></span><br><span class="line">    <span class="comment">// %f: a floating-point value (digits 7, 8, 9)</span></span><br><span class="line">    <span class="comment">// %*d an integer which isn't stored anywhere</span></span><br><span class="line">    <span class="comment">// ' ': all consecutive whitespace</span></span><br><span class="line">    <span class="comment">// %3[0-9]: a string of at most 3 digits (digits 5 and 6)</span></span><br><span class="line">    <span class="comment">// %2lc: two wide characters, using multibyte to wide conversion</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">std</span>::<span class="built_in">sscanf</span>(input, <span class="string">"%d%f%9s%2d%f%*d %3[0-9]%2lc"</span>,</span><br><span class="line">                     &amp;i, &amp;x, str1, &amp;j, &amp;y, str2, warr);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Converted "</span> &lt;&lt; ret &lt;&lt; <span class="string">" fields:\n"</span></span><br><span class="line">              &lt;&lt; <span class="string">"i = "</span> &lt;&lt; i &lt;&lt; <span class="string">"\nx = "</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">              &lt;&lt; <span class="string">"str1 = "</span> &lt;&lt; str1 &lt;&lt; <span class="string">"\nj = "</span> &lt;&lt; j &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">              &lt;&lt; <span class="string">"y = "</span> &lt;&lt; y &lt;&lt; <span class="string">"\nstr2 = "</span> &lt;&lt; str2 &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">              &lt;&lt; <span class="built_in">std</span>::hex &lt;&lt; <span class="string">"warr[0] = U+"</span> &lt;&lt; warr[<span class="number">0</span>]</span><br><span class="line">              &lt;&lt; <span class="string">" warr[1] = U+"</span> &lt;&lt; warr[<span class="number">1</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">Converted 7 fields:</span></span><br><span class="line"><span class="comment">i = 25</span></span><br><span class="line"><span class="comment">x = 5.432</span></span><br><span class="line"><span class="comment">str1 = Thompson</span></span><br><span class="line"><span class="comment">j = 56</span></span><br><span class="line"><span class="comment">y = 789</span></span><br><span class="line"><span class="comment">str2 = 56</span></span><br><span class="line"><span class="comment">warr[0] = U+df warr[1] = U+6c34</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="用istreamstring对象"><a href="#用istreamstring对象" class="headerlink" title="用istreamstring对象"></a>用<code>istreamstring</code>对象</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">istringstream</span> in;  <span class="comment">// could also use in("1 2")</span></span><br><span class="line">    in.str(<span class="string">"1 2"</span>);</span><br><span class="line">    in &gt;&gt; n;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"after reading the first int from \"1 2\", the int is "</span></span><br><span class="line">              &lt;&lt; n &lt;&lt; <span class="string">", str() = \""</span> &lt;&lt; in.str() &lt;&lt; <span class="string">"\"\n"</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">after reading the first int from "1 2", the int is 1, str() = "1 2"</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="用stoi-stof-stod函数"><a href="#用stoi-stof-stod函数" class="headerlink" title="用stoi stof stod函数"></a>用<code>stoi</code> <code>stof</code> <code>stod</code>函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">std::stoi, std::stol, std::stoll</span><br><span class="line">Defined in header &lt;string&gt;</span><br><span class="line">int       stoi( const std::string&amp; str, std::size_t* pos = 0, int base = 10 );</span><br><span class="line">int       stoi( const std::wstring&amp; str, std::size_t* pos = 0, int base = 10 );  (1)	(since C++11)</span><br><span class="line">long      stol( const std::string&amp; str, std::size_t* pos = 0, int base = 10 );</span><br><span class="line">long      stol( const std::wstring&amp; str, std::size_t* pos = 0, int base = 10 );  (2)	(since C++11)</span><br><span class="line">long long stoll( const std::string&amp; str, std::size_t* pos = 0, int base = 10 );</span><br><span class="line">long long stoll( const std::wstring&amp; str, std::size_t* pos = 0, int base = 10 );  (3)	(since C++11)</span><br><span class="line"></span><br><span class="line">std::stoul, std::stoull</span><br><span class="line">Defined in header &lt;string&gt;</span><br><span class="line">unsigned long      stoul( const std::string&amp; str, std::size_t* pos = 0, int base = 10 );</span><br><span class="line">unsigned long      stoul( const std::wstring&amp; str, std::size_t* pos = 0, int base = 10 );  (1)	(since C++11)</span><br><span class="line">unsigned long long stoull( const std::string&amp; str, std::size_t* pos = 0, int base = 10 );</span><br><span class="line">unsigned long long stoull( const std::wstring&amp; str, std::size_t* pos = 0, int base = 10 );  (2)	(since C++11)</span><br><span class="line"></span><br><span class="line">std::stof, std::stod, std::stold</span><br><span class="line">Defined in header &lt;string&gt;</span><br><span class="line">float       stof( const std::string&amp; str, std::size_t* pos = 0 );</span><br><span class="line">float       stof( const std::wstring&amp; str, std::size_t* pos = 0 );  (1)	(since C++11)</span><br><span class="line">double      stod( const std::string&amp; str, std::size_t* pos = 0 );</span><br><span class="line">double      stod( const std::wstring&amp; str, std::size_t* pos = 0 );  (2)	(since C++11)</span><br><span class="line">long double stold( const std::string&amp; str, std::size_t* pos = 0 );</span><br><span class="line">long double stold( const std::wstring&amp; str, std::size_t* pos = 0 );  (3)	(since C++11)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Parameters</strong><br>str    -    the string to convert<br>pos    -    address of an integer to store the number of characters processed<br>base    -    the number base<br><strong>Return value</strong><br>The string converted to the specified signed integer type.<br><strong>Exceptions</strong><br><code>std::invalid_argument</code> if no conversion could be performed<br><code>std::out_of_range</code> if the converted value would fall out of the range of the result type or if the underlying function (std::strtol or std::strtoll) sets errno to ERANGE.</p>
</blockquote>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str1 = <span class="string">"45"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str2 = <span class="string">"3.14159"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str3 = <span class="string">"32 with words"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str4 = <span class="string">"words and 2"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> num = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> myint1 = <span class="built_in">std</span>::stoi(str1);</span><br><span class="line">    <span class="keyword">float</span> myfloat = <span class="built_in">std</span>::stof(str2);</span><br><span class="line">    <span class="keyword">int</span> myint2 = <span class="built_in">std</span>::stoi(str3, &amp;num, <span class="number">16</span>);</span><br><span class="line">    <span class="comment">// error: 'std::invalid_argument'</span></span><br><span class="line">    <span class="comment">// int myint4 = std::stoi(str4);</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"std::stoi(\""</span> &lt;&lt; str1 &lt;&lt; <span class="string">"\") is "</span> &lt;&lt; myint1 &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"std::stof(\""</span> &lt;&lt; str2 &lt;&lt; <span class="string">"\") is "</span> &lt;&lt; myfloat &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"std::stoi(\""</span> &lt;&lt; str3 &lt;&lt; <span class="string">"\""</span> &lt;&lt; <span class="string">" ,&amp;num"</span> &lt;&lt; <span class="string">" ,16"</span> &lt;&lt; <span class="string">") is "</span> &lt;&lt; myint2 &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"num = "</span> &lt;&lt; num &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; "std::stoi(\"" &lt;&lt; str4 &lt;&lt; "\") is " &lt;&lt; myint4 &lt;&lt; '\n';</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">std::stoi("45") is 45</span></span><br><span class="line"><span class="comment">std::stof("3.14159") is 3.14159</span></span><br><span class="line"><span class="comment">std::stoi("32 with words" ,&amp;num ,16) is 50</span></span><br><span class="line"><span class="comment">num = 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="用atoi-atof-strtof函数"><a href="#用atoi-atof-strtof函数" class="headerlink" title="用atoi atof strtof函数"></a>用<code>atoi</code> <code>atof</code> <code>strtof</code>函数</h4><p>这里的一系列函数的输入字符串都是<code>char*</code>，对于C类型的字符串可以用下面这些函数。需要注意的是<code>atoi</code>函数是按10进制解释字符串所表示的整数，如果没有可转换进行时（比如所解析的字符串首字符不是数字或正负号），返回<code>0</code>。
<code>strtol</code>函数可以按照指定的进制解释字符串所表示的整数，<code>strtol</code> <code>strtof</code> <code>strtod</code>函数的第二个参数是<code>char**</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::atoi, <span class="built_in">std</span>::atol, <span class="built_in">std</span>::atoll</span><br><span class="line">Defined in header &lt;cstdlib&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span>       <span class="title">atoi</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *str )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span>      <span class="title">atol</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *str )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">atoll</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *str )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::atof</span><br><span class="line">Defined in header &lt;cstdlib&gt;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">atof</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *str )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::strtof, <span class="built_in">std</span>::strtod, <span class="built_in">std</span>::strtold</span><br><span class="line">Defined in header &lt;cstdlib&gt;</span><br><span class="line"><span class="function"><span class="keyword">float</span>       <span class="title">strtof</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">char</span>** str_end )</span></span>;  (since C++<span class="number">11</span>)</span><br><span class="line"><span class="function"><span class="keyword">double</span>      <span class="title">strtod</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">char</span>** str_end )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">double</span> <span class="title">strtold</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">char</span>** str_end )</span></span>;  (since C++<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::strtol, <span class="built_in">std</span>::strtoll</span><br><span class="line">Defined in header &lt;cstdlib&gt;</span><br><span class="line"><span class="function"><span class="keyword">long</span>      <span class="title">strtol</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">char</span> **str_end, <span class="keyword">int</span> base )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">strtoll</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">char</span> **str_end, <span class="keyword">int</span> base )</span></span>;  (since C++<span class="number">11</span>)</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *str1 = <span class="string">"42"</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *str2 = <span class="string">"3.14159"</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *str3 = <span class="string">"31337 with words"</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *str4 = <span class="string">"words and 2"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> num1 = <span class="built_in">std</span>::atoi(str1);</span><br><span class="line">    <span class="keyword">int</span> num2 = <span class="built_in">std</span>::atoi(str2);</span><br><span class="line">    <span class="keyword">int</span> num3 = <span class="built_in">std</span>::atoi(str3);</span><br><span class="line">    <span class="keyword">int</span> num4 = <span class="built_in">std</span>::atoi(str4);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"std::atoi(\""</span> &lt;&lt; str1 &lt;&lt; <span class="string">"\") is "</span> &lt;&lt; num1 &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"std::atoi(\""</span> &lt;&lt; str2 &lt;&lt; <span class="string">"\") is "</span> &lt;&lt; num2 &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"std::atoi(\""</span> &lt;&lt; str3 &lt;&lt; <span class="string">"\") is "</span> &lt;&lt; num3 &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"std::atoi(\""</span> &lt;&lt; str4 &lt;&lt; <span class="string">"\") is "</span> &lt;&lt; num4 &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">std::atoi("42") is 42</span></span><br><span class="line"><span class="comment">std::atoi("3.14159") is 3</span></span><br><span class="line"><span class="comment">std::atoi("31337 with words") is 31337</span></span><br><span class="line"><span class="comment">std::atoi("words and 2") is 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::atof(<span class="string">"0.0000000123"</span>) &lt;&lt; <span class="string">"\n"</span></span><br><span class="line">              &lt;&lt; <span class="built_in">std</span>::atof(<span class="string">"0.012"</span>) &lt;&lt; <span class="string">"\n"</span></span><br><span class="line">              &lt;&lt; <span class="built_in">std</span>::atof(<span class="string">"15e16"</span>) &lt;&lt; <span class="string">"\n"</span></span><br><span class="line">              &lt;&lt; <span class="built_in">std</span>::atof(<span class="string">"-0x1afp-2"</span>) &lt;&lt; <span class="string">"\n"</span></span><br><span class="line">              &lt;&lt; <span class="built_in">std</span>::atof(<span class="string">"inF"</span>) &lt;&lt; <span class="string">"\n"</span></span><br><span class="line">              &lt;&lt; <span class="built_in">std</span>::atof(<span class="string">"Nan"</span>) &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">1.23e-08</span></span><br><span class="line"><span class="comment">0.012</span></span><br><span class="line"><span class="comment">1.5e+17</span></span><br><span class="line"><span class="comment">-107.75</span></span><br><span class="line"><span class="comment">inf</span></span><br><span class="line"><span class="comment">nan</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* p = <span class="string">"10 200000000000000000000000000000 30 -40"</span>;</span><br><span class="line">    <span class="keyword">char</span> *end;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Parsing '"</span> &lt;&lt; p &lt;&lt; <span class="string">"':\n"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="built_in">std</span>::strtol(p, &amp;end, <span class="number">10</span>);</span><br><span class="line">         p != end;</span><br><span class="line">         i = <span class="built_in">std</span>::strtol(p, &amp;end, <span class="number">10</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"'"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">string</span>(p, end-p) &lt;&lt; <span class="string">"' -&gt; "</span>;</span><br><span class="line">        p = end;</span><br><span class="line">        <span class="keyword">if</span> (errno == ERANGE)&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"range error, got "</span>;</span><br><span class="line">            errno = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">Parsing '10 200000000000000000000000000000 30 -40':</span></span><br><span class="line"><span class="comment">'10' -&gt; 10</span></span><br><span class="line"><span class="comment">' 200000000000000000000000000000' -&gt; range error, got 9223372036854775807</span></span><br><span class="line"><span class="comment">' 30' -&gt; 30</span></span><br><span class="line"><span class="comment">' -40' -&gt; -40</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* p = <span class="string">"111.11 -2.22 0X1.BC70A3D70A3D7P+6  1.18973e+4932zzz"</span>;</span><br><span class="line">    <span class="keyword">char</span>* end;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Parsing \""</span> &lt;&lt; p &lt;&lt; <span class="string">"\":\n"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">double</span> f = <span class="built_in">std</span>::strtod(p, &amp;end); p != end; f = <span class="built_in">std</span>::strtod(p, &amp;end))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"'"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">string</span>(p, end-p) &lt;&lt; <span class="string">"' -&gt; "</span>;</span><br><span class="line">        p = end;</span><br><span class="line">        <span class="keyword">if</span> (errno == ERANGE)&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"range error, got "</span>;</span><br><span class="line">            errno = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; f &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">Parsing "111.11 -2.22 0X1.BC70A3D70A3D7P+6  1.18973e+4932zzz":</span></span><br><span class="line"><span class="comment">'111.11' -&gt; 111.11</span></span><br><span class="line"><span class="comment">' -2.22' -&gt; -2.22</span></span><br><span class="line"><span class="comment">' 0X1.BC70A3D70A3D7P+6' -&gt; 111.11</span></span><br><span class="line"><span class="comment">'  1.18973e+4932' -&gt; range error, got inf</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="Java中如何把数字转换为字符串"><a href="#Java中如何把数字转换为字符串" class="headerlink" title="Java中如何把数字转换为字符串"></a>Java中如何把数字转换为字符串</h3><p>函数原型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span> i,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> radix)</span></span></span><br></pre></td></tr></table></figure>

<p>该函数是类<code>Integer</code>中的一个静态方法，该函数作用是把整数按某一进制转换成字符串并返回。具体的描述如下（摘自Java SE 8参考文档）。</p>
<blockquote>
<p>Returns a string representation of the first argument in the radix specified by the second argument.  If the radix is smaller than <code>Character.MIN_RADIX</code> or larger than <code>Character.MAX_RADIX</code>, then the radix 10 is used instead. </p>
<p>If the first argument is negative, the first element of the result is the ASCII minus character ‘-‘ (‘\u002D’). If the first argument is not negative, no sign character appears in the result.</p>
<p>The remaining characters of the result represent the magnitude of the first argument. If the magnitude is zero, it is represented by a single zero character ‘0’ (‘\u0030’); otherwise, the first character of the representation of the magnitude will not be the zero character.<br>The following ASCII characters are used as digits: </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0123456789abcdefghijklmnopqrstuvwxyz</span><br></pre></td></tr></table></figure>

<blockquote>
<p>These are ‘\u0030’ through ‘\u0039’ and ‘\u0061’ through ‘\u007A’. If radix is N, then the first N of these characters are used as radix-N digits in the order shown. Thus, the digits for hexadecimal (radix 16) are 0123456789abcdef. If uppercase letters are desired, the <code>String.toUpperCase()</code> method may be called on the result:  <code>Integer.toString(n, 16).toUpperCase()</code></p>
</blockquote>
<p>相关函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toUnsignedString</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> radix)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toHexString</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toOctalString</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toBinaryString</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br></pre></td></tr></table></figure>

<p>对于Float、Double、Character向字符串的转换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">float</span> f = -<span class="number">12.70f</span>;</span><br><span class="line">        <span class="keyword">double</span> d = <span class="number">13.54</span>;</span><br><span class="line">        <span class="keyword">char</span> c = <span class="string">'A'</span>;</span><br><span class="line">        String s1 = Integer.toString(a, <span class="number">10</span>);</span><br><span class="line">        String s2 = Float.toString(f);</span><br><span class="line">        String s3 = Float.toHexString(f);</span><br><span class="line">        String s4 = Double.toString(d);</span><br><span class="line">        String s5 = Character.toString(c);</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">        System.out.println(s3);</span><br><span class="line">        System.out.println(s4);</span><br><span class="line">        System.out.println(s5);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        10</span></span><br><span class="line"><span class="comment">        -12.7</span></span><br><span class="line"><span class="comment">        -0x1.966666p3</span></span><br><span class="line"><span class="comment">        13.54</span></span><br><span class="line"><span class="comment">        A</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用String类中的静态方法把int，float，double，char转换为字符串：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">float</span> f = -<span class="number">12.70f</span>;</span><br><span class="line">        <span class="keyword">double</span> d = <span class="number">13.54</span>;</span><br><span class="line">        <span class="keyword">char</span> c = <span class="string">'A'</span>;</span><br><span class="line">        <span class="keyword">char</span>[] arr = &#123;<span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>&#125;;</span><br><span class="line"></span><br><span class="line">        String s1 = String.valueOf(a);</span><br><span class="line">        String s2 = String.valueOf(f);</span><br><span class="line">        String s3 = String.valueOf(d);</span><br><span class="line">        String s4 = String.valueOf(c);</span><br><span class="line">        String s5 = String.valueOf(arr);</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">        System.out.println(s3);</span><br><span class="line">        System.out.println(s4);</span><br><span class="line">        System.out.println(s5);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        10</span></span><br><span class="line"><span class="comment">        -12.7</span></span><br><span class="line"><span class="comment">        13.54</span></span><br><span class="line"><span class="comment">        A</span></span><br><span class="line"><span class="comment">        hello</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Java中如何把字符串转换为数字"><a href="#Java中如何把字符串转换为数字" class="headerlink" title="Java中如何把字符串转换为数字"></a>Java中如何把字符串转换为数字</h3><p>函数原型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parseInt</span><span class="params">(String s,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">int</span> radix)</span></span></span><br><span class="line"><span class="function">                    <span class="keyword">throws</span> NumberFormatException</span></span><br></pre></td></tr></table></figure>

<p>该函数是类<code>Integer</code>中的一个静态方法，该函数作用是把字符串按某一进制转换成整数并返回。具体的描述如下（摘自Java SE 8参考文档）。</p>
<blockquote>
<p>Parses the string argument as a signed integer in the radix specified by the second argument. The characters in the string must all be digits of the specified radix (as determined by whether <code>Character.digit(char, int)</code> returns a nonnegative value), except that the first character may be an ASCII minus sign ‘-‘ (‘\u002D’) to indicate a negative value or an ASCII plus sign ‘+’ (‘\u002B’) to indicate a positive value. The resulting integer value is returned. </p>
</blockquote>
<p>An exception of type <code>NumberFormatException</code> is thrown if any of the following situations occurs: </p>
<ul>
<li>The first argument is null or is a string of length zero. </li>
<li>The radix is either smaller than Character.MIN_RADIX or larger than Character.MAX_RADIX. </li>
<li>Any character of the string is not a digit of the specified radix, except that the first character may be a minus sign ‘-‘ (‘\u002D’) or plus sign ‘+’ (‘\u002B’) provided that the string is longer than length 1. </li>
<li>The value represented by the string is not a value of type int. </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Examples: </span><br><span class="line"> parseInt(<span class="string">"0"</span>, <span class="number">10</span>) returns <span class="number">0</span></span><br><span class="line"> parseInt(<span class="string">"473"</span>, <span class="number">10</span>) returns <span class="number">473</span></span><br><span class="line"> parseInt(<span class="string">"+42"</span>, <span class="number">10</span>) returns <span class="number">42</span></span><br><span class="line"> parseInt(<span class="string">"-0"</span>, <span class="number">10</span>) returns <span class="number">0</span></span><br><span class="line"> parseInt(<span class="string">"-FF"</span>, <span class="number">16</span>) returns -<span class="number">255</span></span><br><span class="line"> parseInt(<span class="string">"1100110"</span>, <span class="number">2</span>) returns <span class="number">102</span></span><br><span class="line"> parseInt(<span class="string">"2147483647"</span>, <span class="number">10</span>) returns <span class="number">2147483647</span></span><br><span class="line"> parseInt(<span class="string">"-2147483648"</span>, <span class="number">10</span>) returns -<span class="number">2147483648</span></span><br><span class="line"> parseInt(<span class="string">"2147483648"</span>, <span class="number">10</span>) <span class="keyword">throws</span> a NumberFormatException</span><br><span class="line"> parseInt(<span class="string">"99"</span>, <span class="number">8</span>) <span class="keyword">throws</span> a NumberFormatException</span><br><span class="line"> parseInt(<span class="string">"Kona"</span>, <span class="number">10</span>) <span class="keyword">throws</span> a NumberFormatException</span><br><span class="line"> parseInt(<span class="string">"Kona"</span>, <span class="number">27</span>) returns <span class="number">411787</span></span><br></pre></td></tr></table></figure>

<p>和它对应的还有一个函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parseInt</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function">                    <span class="keyword">throws</span> NumberFormatException</span></span><br></pre></td></tr></table></figure>

<p>该函数是默认按照十进制进行转换的。<br>字符串转换到Double、Float：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="keyword">new</span> String(<span class="string">"-0100"</span>);</span><br><span class="line">        String s2 = <span class="string">"0.0050"</span>;</span><br><span class="line">        String s3 = <span class="string">"23.98f"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = Integer.parseInt(s1, <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">float</span> f = Float.parseFloat(s2);</span><br><span class="line">        <span class="keyword">double</span> d = Double.parseDouble(s3);</span><br><span class="line"></span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(f);</span><br><span class="line">        System.out.println(d);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        -100</span></span><br><span class="line"><span class="comment">        0.005</span></span><br><span class="line"><span class="comment">        23.98</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://evanqiao.github.io/xiaojn-blog/2017/04/09/C++和Java中字符串与数字的相互转换/" data-id="cjxbtu1nb0008qo67idmzvry1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/xiaojn-blog/tags/Algorithm/">Algorithm</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Hexo博客建站流程备忘" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/xiaojn-blog/2017/03/20/Hexo博客建站流程备忘/" class="article-date">
  <time datetime="2017-03-20T13:15:36.000Z" itemprop="datePublished">2017-03-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/xiaojn-blog/categories/博客建设/">博客建设</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/xiaojn-blog/2017/03/20/Hexo博客建站流程备忘/">Hexo博客建站流程备忘</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。<br>基于Hexo搭建的博客可以部署在自己的服务器上（腾讯云、阿里云等），也可以部署在github上，部署在github上更为方便，节省成本，管理也方便。</p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>事先需要安装：</p>
<ul>
<li><a href="http://nodejs.org/" target="_blank" rel="noopener">Node.js</a></li>
<li><a href="http://git-scm.com/" target="_blank" rel="noopener">Git</a></li>
</ul>
<p>安装Hexo：</p>
<p><code>$ npm install -g hexo-cli</code></p>
<p>具体的安装方法可参考<a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">官方文档</a>。</p>
<h2 id="域名设置"><a href="#域名设置" class="headerlink" title="域名设置"></a>域名设置</h2><p>我在腾讯云上申请的域名是<code>xiaojn.cn</code>，看到<a href="http://blog.fens.me/hexo-blog-github/" target="_blank" rel="noopener">这篇文章</a>中说可以把blog的域名设置为子域名。下面是我的设置内容。<br>![子域名配置][2]<br>![CNAME文件][1]<br>在dnspod控制台，我们要做3步设置。</p>
<ul>
<li>设置主机记录github，类型A，到IP 199.27.76.133</li>
<li>设置主机记录evanqiao.github.io，类型CNAME，到github.xiaojn.cn.</li>
<li>设置主机记录blog，类型CNAME，到 evanqiao.github.io<br>记得我们还要修改文件CNAME，改为blog.xiaojn.cn。通过浏览器，访问<a href="http://blog.xiaojn.cn" target="_blank" rel="noopener">http://blog.xiaojn.cn</a>，就可以打开了我们的博客站点了，而这次用的是二级域名。</li>
</ul>
<p>由于每次执行deploy的时候，gh-pages分支所有的文件都会被覆盖，所以我们最好在source目录下创建这个CNAME文件，这样每次部署就不用动手创建了。</p>
<h2 id="主题安装"><a href="#主题安装" class="headerlink" title="主题安装"></a>主题安装</h2><p>选了一圈主题，最好还是觉得<code>maupassant</code>这个主题比较简洁。最终选择的是<code>tufu9441</code>在原来的主题上进行二次开发过的<code>maupassant</code>主题。<br>安装主题和渲染器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/tufu9441/maupassant-hexo.git themes/maupassant</span><br><span class="line">$ npm install hexo-renderer-jade --save</span><br><span class="line">$ npm install hexo-renderer-sass --save</span><br></pre></td></tr></table></figure>

<p>编辑Hexo目录下的 _config.yml，将theme的值改为maupassant。<br>作者提供的中文使用<a href="https://www.haomwei.com/technology/maupassant-hexo.html" target="_blank" rel="noopener">教程</a>。
需要注意的是：</p>
<ol>
<li>在配置hexo的_config.yml时，其实是有两个的，一个是hexo的基础配置，主要配置网站相关的信息，一个是对主题的配置，放置在主题对应的目录下面。</li>
<li>在_config.yml中配置Deployment中，type应该是git而不是github,这是由于版本更新导致的。</li>
<li>在安装<code>hexo-renderer-sass</code>时可能导致出错，是因为被墙的原因，可以换用国内的<a href="http://npm.taobao.org/" target="_blank" rel="noopener">淘宝NPM镜像</a>。如果没有安装成功的话，首先你需要卸载才可以继续用cnpm继续安装的:<code>npm uninstall  hexo-renderer-sass --save</code>不然还会出错,如果你忽略这个错误，那么等你部署上去的时候，你会发现你的网站没有样式。</li>
</ol>
<h2 id="发布到github"><a href="#发布到github" class="headerlink" title="发布到github"></a>发布到github</h2><p>在github上创建一个repository，然后在hexo的配置文件_config.yml<br>中添加部署内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line">repo: git@github.com:Evanqiao/xiaojn-blog.git</span><br></pre></td></tr></table></figure>

<p>这个静态的web网站就被部署到了github，分支是gh-pages，gh-pages是github为了web项目特别设置的分支。<br>为了备份博客内容和搭建的hexo环境，我这里把hexo的环境和source/目录下的内容备份到了<code>git@github.com:Evanqiao/xiaojn-blog.git</code>的master分支中。<br>其他关于hexo博客的插件安装、部署、maupassant主题的使用等内容详见参考链接。<br>  [1]: /images/CNAME.png<br>  [2]: /images/subdomain_config.png</p>
<p>Ref：</p>
<ul>
<li><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo官方文档</a></li>
<li><a href="https://www.haomwei.com/technology/maupassant-hexo.html" target="_blank" rel="noopener">maupassant主题的使用：大道至简——Hexo简洁主题推荐</a></li>
<li><a href="http://rockcoding.com/2016/03/02/hexo/" target="_blank" rel="noopener">使用hexo时遇到的小坑</a></li>
<li><a href="http://blog.fens.me/hexo-blog-github/" target="_blank" rel="noopener">Hexo在github上构建免费的Web应用</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://evanqiao.github.io/xiaojn-blog/2017/03/20/Hexo博客建站流程备忘/" data-id="cjxbtu1n20002qo6749q2dz6h" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/xiaojn-blog/tags/hexo/">hexo</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-典型排序算法回顾" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/xiaojn-blog/2016/08/25/典型排序算法回顾/" class="article-date">
  <time datetime="2016-08-25T07:03:35.000Z" itemprop="datePublished">2016-08-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/xiaojn-blog/categories/算法/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/xiaojn-blog/2016/08/25/典型排序算法回顾/">典型排序算法回顾</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>本文内容</strong>：</p>
<ul>
<li><input checked disabled type="checkbox"> 1.排序算法的分类  </li>
<li><input checked disabled type="checkbox"> 2.基于插入的排序  </li>
<li><input checked disabled type="checkbox"> 3.冒泡排序  </li>
<li><input checked disabled type="checkbox"> 4.快速排序  </li>
<li><input checked disabled type="checkbox"> 5.归并排序  </li>
<li><input checked disabled type="checkbox"> 6.选择排序  </li>
<li><input checked disabled type="checkbox"> 7.堆排序  </li>
</ul>
<h2 id="1-排序算法的分类"><a href="#1-排序算法的分类" class="headerlink" title="1. 排序算法的分类"></a>1. 排序算法的分类</h2><p>Sorting algorithms are often classified by: (<a href="https://en.wikipedia.org/wiki/Sorting_algorithm#Classification" target="_blank" rel="noopener">Reference link</a>)</p>
<ul>
<li>Computational complexity (worst, average and best behavior) in terms of the size of the list (n). For typical serial sorting algorithms good behavior is O(n log n), with parallel sort in O(log2 n), and bad behavior is O(n2). (See Big O notation.) Ideal behavior for a serial sort is O(n), but this is not possible in the average case. Optimal parallel sorting is O(log n). Comparison-based sorting algorithms, need at least O(n log n) comparisons for most inputs.</li>
<li>Computational complexity of swaps (for “in-place” algorithms).</li>
<li>Memory usage (and use of other computer resources). In particular, some sorting algorithms are “in-place”. Strictly, an in-place sort needs only O(1) memory beyond the items being sorted; sometimes O(log(n)) additional memory is considered “in-place”.</li>
<li>Recursion. Some algorithms are either recursive or non-recursive, while others may be both (e.g., merge sort).</li>
<li>Stability: stable sorting algorithms maintain the relative order of records with equal keys (i.e., values).</li>
<li>Whether or not they are a comparison sort. A comparison sort examines the data only by comparing two elements with a comparison operator.</li>
<li>General method: insertion, exchange, selection, merging, etc. Exchange sorts include bubble sort and quicksort. Selection sorts include shaker sort and heapsort. Also whether the algorithm is serial or parallel. The remainder of this discussion almost exclusively concentrates upon serial algorithms and assumes serial operation.</li>
<li>Adaptability: Whether or not the presortedness of the input affects the running time. Algorithms that take this into account are known to be adaptive.</li>
</ul>
<h3 id="1-1-稳定性"><a href="#1-1-稳定性" class="headerlink" title="1.1 稳定性"></a>1.1 稳定性</h3><p>排序算法的稳定性指的是，数组中相等元素在排序后，他们的相对位置不发生改变。<br>稳定排序算法的一个应用是：用第一和第二主键对数组进行排序。<br>比如对扑克牌，要求按数字大小进行排序，和按照花色进行排序（梅花、方块、红桃、黑桃），对于同一种花色，数字按照从小到大进行排序。第一轮按照数字从小到大进行排序（用任一种排序方法），第二轮用稳定的排序算法进行排序。<br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/79/Sorting_playing_cards_using_stable_sort.svg/400px-Sorting_playing_cards_using_stable_sort.svg.png" alt="image"></p>
<h3 id="1-2-排序算法的比较"><a href="#1-2-排序算法的比较" class="headerlink" title="1.2 排序算法的比较"></a>1.2 排序算法的比较</h3><p><a href="https://en.wikipedia.org/wiki/Sorting_algorithm#Comparison_of_algorithms" target="_blank" rel="noopener">参考链接（维基百科）</a></p>
<p><img src="http://img.blog.csdn.net/20160607144411150" alt="image"></p>
<h2 id="2-基于插入的排序算法"><a href="#2-基于插入的排序算法" class="headerlink" title="2. 基于插入的排序算法"></a>2. 基于插入的排序算法</h2><h3 id="2-1-直接插入排序"><a href="#2-1-直接插入排序" class="headerlink" title="2.1 直接插入排序"></a>2.1 直接插入排序</h3><p><a href="https://en.wikipedia.org/wiki/Insertion_sort" target="_blank" rel="noopener">Insertion sort</a> is a simple sorting algorithm that is relatively efficient for small lists and mostly sorted lists, and is often used as part of more sophisticated algorithms. It works by taking elements from the list one by one and inserting them in their correct position into a new sorted list.[17] In arrays, the new list and the remaining elements can share the array’s space, but insertion is expensive, requiring shifting all following elements over by one. Shell sort (see below) is a variant of insertion sort that is more efficient for larger lists.</p>
<p>It is much less efficient on large lists than more advanced algorithms such as quicksort, heapsort, or merge sort. However, insertion sort provides several advantages:</p>
<ul>
<li>Simple implementation: Bentley shows a three-line C version, and a five-line optimized version</li>
<li>Efficient for (quite) small data sets, much like other quadratic sorting algorithms</li>
<li>More efficient in practice than most other simple quadratic (i.e., O(n2)) algorithms such as selection sort or bubble sort</li>
<li>Adaptive, i.e., efficient for data sets that are already substantially sorted: the time complexity is O(nk) when each element in the input is no more than k places away from its sorted position</li>
<li>Stable; i.e., does not change the relative order of elements with equal keys</li>
<li>In-place; i.e., only requires a constant amount O(1) of additional memory space</li>
<li>Online; i.e., can sort a list as it receives it</li>
</ul>
<table>
<thead>
<tr>
<th align="left">Worst case performance</th>
<th align="left">О(n2) comparisons, swaps</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Best case performance</td>
<td align="left">O(n) comparisons, O(1) swaps</td>
</tr>
<tr>
<td align="left">Average case performance</td>
<td align="left">О(n2) comparisons, swaps</td>
</tr>
<tr>
<td align="left">Worst case space complexity</td>
<td align="left">О(n) total, O(1) auxiliary</td>
</tr>
</tbody></table>
<p>Insertion sort algorithm somewhat resembles selection sort. Array is imaginary divided into two parts - sorted one and unsorted one. At the beginning, sorted part contains first element of the array and unsorted one contains the rest. At every step, algorithm takes first element in the unsorted part and inserts it to the right place of the sorted one. When unsorted part becomes empty, algorithm stops. Sketchy, insertion sort algorithm step looks like this:</p>
<p><img src="http://www.algolist.net/img/sorts/insertion-sort-sketchy-before.png" alt="image"><br>becomes<br><img src="http://www.algolist.net/img/sorts/insertion-sort-sketchy-after.png" alt="image"></p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif" alt="image"></p>
<p>下面是插入排序的伪代码：（数组是从下标0开始的）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">INSERTION-SORT(A)</span><br><span class="line"><span class="keyword">for</span> j = <span class="number">1</span> to A.length</span><br><span class="line">    key = A[j]</span><br><span class="line">    <span class="comment">// Insert A[j] into the sorted sequence A[1..j-1]</span></span><br><span class="line">    i = j - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> A[i] &gt; key</span><br><span class="line">        A[i + <span class="number">1</span>] = A[i]</span><br><span class="line">        i = i - <span class="number">1</span></span><br><span class="line">    A[i + <span class="number">1</span>] = key</span><br></pre></td></tr></table></figure>

<p>C++语言实现（方法一：通过后移把元素放到正确的位置上）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> key = A[i];</span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; A[j] &gt; key) &#123;</span><br><span class="line">            A[j + <span class="number">1</span>] = A[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        A[j + <span class="number">1</span>] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C++语言实现（方法二：通过交换把元素放到正确的位置上）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertion_sort2</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    	<span class="keyword">int</span> j = i;	</span><br><span class="line">    	<span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; A[j - <span class="number">1</span>] &gt; A[j]) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = A[j - <span class="number">1</span>];	</span><br><span class="line">            A[j - <span class="number">1</span>] = A[j];</span><br><span class="line">            A[j] = temp;</span><br><span class="line">            j--;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对链表的直接插入排序"><a href="#对链表的直接插入排序" class="headerlink" title="对链表的直接插入排序"></a>对链表的直接插入排序</h3><p>If the items are stored in a linked list, then the list can be sorted with O(1) additional space. The algorithm starts with an initially empty (and therefore trivially sorted) list. The input items are taken off the list one at a time, and then inserted in the proper place in the sorted list. When the input list is empty, the sorted list has the desired result.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct LIST * <span class="title">SortList1</span><span class="params">(struct LIST * pList)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// zero or one element in list</span></span><br><span class="line">    <span class="keyword">if</span>(pList == <span class="literal">NULL</span> || pList-&gt;pNext == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> pList;</span><br><span class="line">    <span class="comment">// head is the first element of resulting sorted list</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LIST</span> * <span class="title">head</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(pList != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">LIST</span> * <span class="title">current</span> = <span class="title">pList</span>;</span></span><br><span class="line">        pList = pList-&gt;pNext;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span> || current-&gt;iValue &lt; head-&gt;iValue) &#123;</span><br><span class="line">            <span class="comment">// insert into the head of the sorted list</span></span><br><span class="line">            <span class="comment">// or as the first element into an empty sorted list</span></span><br><span class="line">            current-&gt;pNext = head;</span><br><span class="line">            head = current;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// insert current element into proper position in non-empty sorted list</span></span><br><span class="line">            struct LIST * p = head;</span><br><span class="line">            <span class="keyword">while</span>(p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;pNext == <span class="literal">NULL</span> || <span class="comment">// last element of the sorted list</span></span><br><span class="line">                   current-&gt;iValue &lt; p-&gt;pNext-&gt;iValue) <span class="comment">// middle of the list</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// insert into middle of the sorted list or as the last element</span></span><br><span class="line">                    current-&gt;pNext = p-&gt;pNext;</span><br><span class="line">                    p-&gt;pNext = current;</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// done</span></span><br><span class="line">                &#125;</span><br><span class="line">                p = p-&gt;pNext;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The algorithm below uses a trailing pointer[6] for the insertion into the sorted list. A simpler recursive method rebuilds the list each time (rather than splicing) and can use O(n) stack space.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LIST</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">LIST</span> * <span class="title">pNext</span>;</span></span><br><span class="line">  <span class="keyword">int</span>           iValue;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">struct LIST * <span class="title">SortList</span><span class="params">(struct LIST * pList)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// zero or one element in list</span></span><br><span class="line">  <span class="keyword">if</span>(!pList || !pList-&gt;pNext)</span><br><span class="line">      <span class="keyword">return</span> pList;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* build up the sorted array from the empty list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">LIST</span> * <span class="title">pSorted</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* take items off the input list one by one until empty */</span></span><br><span class="line">  <span class="keyword">while</span> (pList != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">/* remember the head */</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">LIST</span> *   <span class="title">pHead</span>  = <span class="title">pList</span>;</span></span><br><span class="line">      <span class="comment">/* trailing pointer for efficient splice */</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">LIST</span> ** <span class="title">ppTrail</span> = &amp;<span class="title">pSorted</span>;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* pop head off list */</span></span><br><span class="line">      pList = pList-&gt;pNext;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* splice head into sorted list at proper place */</span></span><br><span class="line">      <span class="keyword">while</span> (!(*ppTrail == <span class="literal">NULL</span> || pHead-&gt;iValue &lt; (*ppTrail)-&gt;iValue)) <span class="comment">/* does head belong here? */</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">/* no - continue down the list */</span></span><br><span class="line">          ppTrail = &amp;(*ppTrail)-&gt;pNext;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      pHead-&gt;pNext = *ppTrail;</span><br><span class="line">      *ppTrail = pHead;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pSorted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-希尔排序"><a href="#2-2-希尔排序" class="headerlink" title="2.2 希尔排序"></a>2.2 希尔排序</h3><p>Shellsort, named after its inventor, Donald Shell, relies upon the fact that insertion sort does very well if the array is nearly sorted. Another way of saying this, is that insertion sort does well if it does not have to move each item “too far”. The idea is to repeatedly do insertion sort on all elements at fixed, decreasing distances apart: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 这里的数学公式 $h_k, h_&#123;k-1&#125;, ..., h_1=1$</span><br><span class="line">// 用maupassant主题自带的LaTeX渲染会出问题，不能正常渲染</span><br><span class="line">h_k, h_&#123;k-1&#125;, ..., h_1 = 1</span><br></pre></td></tr></table></figure>

<p>The choice of increments turns out to be crucial. It turns out that a good choice of increments are these:<br>$h_1= 1, h_2= 3, h_3= 7, …, h_k= 2^k-1$<br>These increments are termed the Hibbard increments. The original increments suggested by the algorithm’s inventor were simple powers of 2, but the Hibbard increments do provably much better. To be able to use the $h_k$ increment, you need an array of size at least $h_k + 1$.</p>
<h4 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h4><p>The psuedo-code for shellSort using the Hibbard increments is as follows:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">find k0 so that <span class="number">2</span>^k0- <span class="number">1</span> &lt; size</span><br><span class="line"><span class="keyword">for</span> (k = k0; k &gt; <span class="number">0</span>; --k) &#123;  <span class="comment">// from larger increments to smaller</span></span><br><span class="line">    inc = <span class="number">2</span>^k- <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; inc; ++i) &#123;</span><br><span class="line">        Sort the elements ( a[i], a[i+inc], a[i+<span class="number">2</span>*inc], ...) <span class="keyword">using</span> insertionSort</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The fact that the last increment in the sequence is 1 means that regular insertion sort is done at the last step and therefore the array is guaranteed to be sorted by this procedure. The point is that when the increments are larger, there are fewer elements and they will be moved further than simply interchanging adjacent elements. At the last step, we do regular insertion sort and hopefully the array is “nearly sorted” which makes insertion sort come close to its best case behavior of running in linear time.</p>
<p>The notion that this is an speed improvement seems initially far-fetched. There are two enclosing for loops to get to an insertion sort, thus this algorithm has <strong>four enclosing loops</strong>.</p>
<h4 id="希尔排序的C-代码实现"><a href="#希尔排序的C-代码实现" class="headerlink" title="希尔排序的C++代码实现"></a>希尔排序的C++代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// find k0 so that 2^k0 - 1 &lt; n</span></span><br><span class="line">    <span class="keyword">int</span> k0 = <span class="built_in">std</span>::log2(n);</span><br><span class="line">    <span class="comment">// from larger increments to smaller</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = k0; k &gt; <span class="number">0</span>; --k) &#123;</span><br><span class="line">        <span class="keyword">int</span> inc = <span class="built_in">std</span>::<span class="built_in">pow</span>(<span class="number">2</span>, k) - <span class="number">1</span>;	</span><br><span class="line">        <span class="comment">// inc rounds insertion-sort</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inc; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + inc; j &lt; n; j += inc) &#123;</span><br><span class="line">                <span class="keyword">int</span> key = A[j];</span><br><span class="line">                <span class="keyword">int</span> m = j - inc; </span><br><span class="line">                <span class="keyword">while</span>(m &gt;= i &amp;&amp; A[m] &gt; key) &#123;</span><br><span class="line">                    A[m	+ inc] = A[m];</span><br><span class="line">                    m -= inc;</span><br><span class="line">                &#125;</span><br><span class="line">                A[m + inc] = key;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ShellSort-Analysis"><a href="#ShellSort-Analysis" class="headerlink" title="ShellSort Analysis"></a>ShellSort Analysis</h4><h5 id="Stability"><a href="#Stability" class="headerlink" title="Stability"></a>Stability</h5><p>Shellsort is <strong>not</strong> stable. It can be readily demonstrated with an array of size 4 (the smallest possible). Instability is to be expected because the increment-based sorts move elements distances without examining of elements in between.</p>
<h5 id="Shellsort-has-O-n-log-n-best-case-time"><a href="#Shellsort-has-O-n-log-n-best-case-time" class="headerlink" title="Shellsort has O(n*log(n)) best case time"></a>Shellsort has O(n*log(n)) best case time</h5><p>The best case, like insertion sort, is when the array is already sorted. Then the number of comparisons for each of the increment-based insertion sorts is the length of the array. Therefore we can determine:<br>comparisons =<br>   n, for 1 sort with elements 1-apart (last step) </p>
<ul>
<li>3 * n/3, for 3 sorts with elements 3-apart (next-to-last step) </li>
<li>7 * n/7, for 7 sorts with elements 7-apart </li>
<li>15 * n/15, for 15 sorts with elements 15-apart </li>
<li>…<br>Each term is n. The question is how many terms are there? The number of terms is the value k such that<br>2^k - l  &lt; n<br>So k &lt; log(n+1), meaning that the sorting time in the best case is less than n * log(n+1) = O(n*log(n)).</li>
</ul>
<h5 id="Shellsort-worst-case-time-is-no-worse-than-quadratic"><a href="#Shellsort-worst-case-time-is-no-worse-than-quadratic" class="headerlink" title="Shellsort worst case time is no worse than quadratic"></a>Shellsort worst case time is no worse than quadratic</h5><p>The argument is similar as previous, but with a different overall computation.<br>comparisons ≤<br>   n^2, for 1 sort with elements 1-apart (last step) </p>
<ul>
<li>3 * (n/3)^2, for 3 sorts with elements 3-apart (next-to-last step) </li>
<li>7 * (n/7)^2, for 7 sorts with elements 7-apart </li>
<li>15 * (n/15)^2, for 15 sorts with elements 15-apart </li>
<li>…<br>And so, with a bit of arithmetic, we can see that the number of comparisons is bounded by:<br>n^2 * (1 + 1/3 + 1/7 + 1/15 + 1/31 + …)<br>&lt; n^2 * (1 + 1/2 + 1/4 + 1/8 + 1/16 + …)<br>= n^2 * 2<br>The last step uses the sum of the geometric series.</li>
</ul>
<h5 id="Shellsort-worst-and-average-times"><a href="#Shellsort-worst-and-average-times" class="headerlink" title="Shellsort worst and average times"></a>Shellsort worst and average times</h5><p>The point about this algorithm is that the initial sorts, acting on elements at larger increments apart involve fewer elements, even considering a worst-case scenario. At these larger increments, “far-away” elements are swapped so that the number of inversions is dramatically reduced. At the later sorts of sorts at smaller increments, the behavior then comes closer to optimal behavior.<br>It can be proved that the worst-case time is sub-quadratic at $O(n^{3/2}) = O(n^{1.5}$<br>As can be expected, the proof is quite difficult. The textbook remarks that the average case time is unknown although conjectured to be $O(n^{5/4}) = O(n^{1.25})$<br>maybe it is (<a href="https://en.wikipedia.org/wiki/Shellsort" target="_blank" rel="noopener">from wikipedia</a>) $O(nlog^2n)$<br>The textbook also mentions other increment sequences which have been studied and seen to produce even better performance.</p>
<p>Reference Link: <a href="http://www.cs.wcupa.edu/rkline/ds/shell-comparison.html" target="_blank" rel="noopener">希尔排序</a></p>
<h2 id="3-冒泡排序"><a href="#3-冒泡排序" class="headerlink" title="3. 冒泡排序"></a>3. 冒泡排序</h2><p>Bubble sort, sometimes referred to as sinking sort, is a simple sorting algorithm that repeatedly steps through the list to be sorted, compares each pair of adjacent items and swaps them if they are in the wrong order. The pass through the list is repeated until no swaps are needed, which indicates that the list is sorted. The algorithm, which is a comparison sort, is named for the way smaller elements “bubble” to the top of the list. Although the algorithm is simple, it is too slow and impractical for most problems even when compared to insertion sort. It can be practical if the input is usually in sorted order but may occasionally have some out-of-order elements nearly in position.<br>注：正确的是顺序是小的在前，大的在后。</p>
<p>在输入规模较大时，冒泡排序的效率还不如插入排序，所以冒泡排序虽然简单，但是大多数时候并不使用它。</p>
<p>冒泡排序的演示如下图所示：<br><img src="https://upload.wikimedia.org/wikipedia/commons/c/c8/Bubble-sort-example-300px.gif" alt="image"></p>
<p>冒泡排序的C++实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[j] &gt; A[j + <span class="number">1</span>])	&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = A[j];</span><br><span class="line">                A[j] = A[j + <span class="number">1</span>];</span><br><span class="line">                A[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对冒泡排序常见的改进方法是加入一标志性变量exchange，用于标志某一趟排序过程中是否有数据交换，如果进行某一趟排序时并没有进行数据交换，则说明数据已经按要求排列好，可立即结束排序，避免不必要的比较过程。设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。<br>冒泡排序的改进一：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort2</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = n - <span class="number">1</span>;    <span class="comment">//初始时,最后位置保持不变 </span></span><br><span class="line">    <span class="keyword">while</span>(i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;  <span class="comment">//每趟开始时,无记录交换</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[j] &gt; A[j + <span class="number">1</span>])	&#123;</span><br><span class="line">                pos = j;	<span class="comment">//记录交换的位置</span></span><br><span class="line">                <span class="keyword">int</span> temp = A[j];</span><br><span class="line">                A[j] = A[j + <span class="number">1</span>];</span><br><span class="line">                A[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;	</span><br><span class="line">        i = pos;     <span class="comment">//为下一趟排序作准备</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="http://blog.csdn.net/hguisu/article/details/7776068" target="_blank" rel="noopener">八大排序算法</a>一文中，对冒泡排序算法做了另外的一种改进，如下代码所示，每一趟进行正反向的冒泡排序，同时找到最大值和最小值，<strong>不过我感觉此法并没有减少循环的次数</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort3</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> temp, i;</span><br><span class="line">    <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">for</span>(i = low; i &lt; high; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] &gt; A[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                temp = A[i];</span><br><span class="line">                A[i] = A[i + <span class="number">1</span>];</span><br><span class="line">                A[i + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;	</span><br><span class="line">        &#125;	</span><br><span class="line">        high--;</span><br><span class="line">        <span class="keyword">for</span>(i = high; i &gt; low; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i - <span class="number">1</span>] &gt; A[i]) &#123;</span><br><span class="line">                temp = A[i - <span class="number">1</span>];</span><br><span class="line">                A[i - <span class="number">1</span>] = A[i];</span><br><span class="line">                A[i] = temp;</span><br><span class="line">            &#125;	</span><br><span class="line">        &#125;	</span><br><span class="line">        low++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="冒泡排序算法复杂度分析"><a href="#冒泡排序算法复杂度分析" class="headerlink" title="冒泡排序算法复杂度分析"></a>冒泡排序算法复杂度分析</h4><table>
<thead>
<tr>
<th align="left">Data structure</th>
<th align="left">Array</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Best case performance</td>
<td align="left">O(n)</td>
</tr>
<tr>
<td align="left">Worst case performance</td>
<td align="left">O(n^2)</td>
</tr>
<tr>
<td align="left">Average case performance</td>
<td align="left">О(n^2)</td>
</tr>
<tr>
<td align="left">Worst case space complexity</td>
<td align="left">O(1) auxiliary</td>
</tr>
</tbody></table>
<h2 id="4-快速排序"><a href="#4-快速排序" class="headerlink" title="4. 快速排序"></a>4. 快速排序</h2><p>Quicksort (sometimes called partition-exchange sort) is an efficient sorting algorithm, serving as a systematic method for placing the elements of an array in order. Developed by Tony Hoare in 1959, with his work published in 1961, it is still a commonly used algorithm for sorting. When implemented well, it can be about two or three times faster than its main competitors, merge sort and heapsort.<a href="https://en.wikipedia.org/wiki/Quicksort" target="_blank" rel="noopener">Quicksort</a></p>
<p>The quicksort algorithm is another classic divide and conquer algorithm. Unlike merge-sort, which does merging after solving the two subproblems, quicksort does all its work upfront.</p>
<p>Quicksort is a comparison sort, meaning that it can sort items of any type for which a “less-than” relation (formally, a total order) is defined. In efficient implementations it is <strong>not a stable sort</strong>, meaning that the relative order of equal sort items is not preserved. Quicksort can operate in-place on an array, requiring small additional amounts of memory to perform the sorting.</p>
<p>Mathematical analysis of quicksort shows that, on average, the algorithm takes O(n log n) comparisons to sort n items. In the worst case, it makes O(n^2) comparisons, though this behavior is rare.</p>
<h3 id="4-1-快速排序的几种算法描述"><a href="#4-1-快速排序的几种算法描述" class="headerlink" title="4.1 快速排序的几种算法描述"></a>4.1 快速排序的几种算法描述</h3><h4 id="4-1-1-快速排序的描述和Java代码实现-Open-Data-Structures-in-Java"><a href="#4-1-1-快速排序的描述和Java代码实现-Open-Data-Structures-in-Java" class="headerlink" title="4.1.1 快速排序的描述和Java代码实现(Open Data Structures(in Java))"></a>4.1.1 快速排序的描述和Java代码实现(<a href="http://opendatastructures.org/versions/edition-0.1e/ods-java/11_1_Comparison_Based_Sorti.html#SECTION001412000000000000000" target="_blank" rel="noopener">Open Data Structures(in Java)</a>)</h4><p>Quicksort is simple to describe: Pick a random pivot element,  <code>x</code>, from array <code>A</code>; partition <code>A</code> into the set of elements less than  <code>x</code>, the set of elements equal to  <code>x</code>, and the set of elements greater than  <code>x</code>; and, finally, recursively sort the first and third sets in this partition. An example is shown in Figure.<br><img src="http://opendatastructures.org/versions/edition-0.1e/ods-java/img1399.png" alt="image"><br>An example execution of <code>quickSort(a,0,14,c)</code></p>
<p>Java代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(T[] a, Comparator&lt;T&gt; c)</span> </span>&#123;</span><br><span class="line">    quickSort(a, <span class="number">0</span>, a.length, c);</span><br><span class="line">&#125;</span><br><span class="line">&lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(T[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> n, Comparator&lt;T&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    T x = a[i + rand.nextInt(n)];</span><br><span class="line">    <span class="keyword">int</span> p = i-<span class="number">1</span>, j = i, q = i+n;</span><br><span class="line">    <span class="comment">// a[i..p]&lt;x,  a[p+1..q-1]??x, a[q..i+n-1]&gt;x </span></span><br><span class="line">    <span class="keyword">while</span> (j &lt; q) &#123;</span><br><span class="line">        <span class="keyword">int</span> comp = compare(a[j], x);</span><br><span class="line">        <span class="keyword">if</span> (comp &lt; <span class="number">0</span>) &#123;       <span class="comment">// move to beginning of array</span></span><br><span class="line">            swap(a, j++, ++p);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (comp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            swap(a, j, --q);  <span class="comment">// move to end of array</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j++;              <span class="comment">// keep in the middle</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// a[i..p]&lt;x,  a[p+1..q-1]=x, a[q..i+n-1]&gt;x </span></span><br><span class="line">    quickSort(a, i, p-i+<span class="number">1</span>, c);</span><br><span class="line">    quickSort(a, q, n-(q-i), c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-1-2-算法导论一书中第7章快速排序的描述"><a href="#4-1-2-算法导论一书中第7章快速排序的描述" class="headerlink" title="4.1.2 算法导论一书中第7章快速排序的描述"></a>4.1.2 算法导论一书中第7章快速排序的描述</h4><p><strong><a href="https://en.wikipedia.org/wiki/Quicksort#Lomuto_partition_scheme" target="_blank" rel="noopener">Lomuto partition scheme</a></strong></p>
<p>This scheme is attributed to Nico Lomuto and popularized by Bentley in his book Programming Pearls and Cormen et al. in their book <strong>Introduction to Algorithms</strong>. This scheme chooses a pivot which is typically the last element in the array. The algorithm maintains the index to put the pivot in variable i and each time it finds an element less than or equal to pivot, this index is incremented and that element would be placed before the pivot. As this scheme is more compact and easy to understand, it is frequently used in introductory material, although it is less efficient than Hoare’s original scheme. This scheme degrades to O(n^2) when the array is already sorted as well as when the array has all equal elements. There have been various variants proposed to boost performance including various ways to select pivot, deal with equal elements, use other sorting algorithms such as Insertion sort for small arrays and so on.</p>
<p>与归并排序一样，快速排序也使用了分治思想。下面是对一个典型的子数组A[p..r]进行快速排序的三步分治过程：</p>
<p><strong>分解</strong>：数组A[p..r]被划分为两个（可能为空）子数组A[p..q-1]和A[q+1..r]，使得A[p..q-1]中的每一个元素都小于等于A[q],而A[q]也小于等于A[q+1..r]中的每个元素。其中，计算下标q也是划分过程的一部分。<br><strong>解决</strong>：通过递归调用快速排序，对子数组A[p..q-1]和A[q+1..r]进行排序。<br><strong>合并</strong>：因为子数组都是原址排序的，所以不需要合并操作：数组A[p..r]已经有序。</p>
<p>假设数组的下标从0开始，算法的伪代码如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">QUICKSORT(A, p, r)</span><br><span class="line"><span class="keyword">if</span> p &lt; r</span><br><span class="line">    q = PARTITION(A, p, r)</span><br><span class="line">    QUICKSORT(A, p, q - <span class="number">1</span>)</span><br><span class="line">    QUICKSORT(A, q + <span class="number">1</span>, r)</span><br><span class="line">    </span><br><span class="line">PARTITION(A, p, r)</span><br><span class="line">x = A[r]</span><br><span class="line">i = p - <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> j = p to r - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> A[j] &lt;= x</span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">        exchange A[i] with A[j]</span><br><span class="line">exchange A[i + <span class="number">1</span>] with A[r]</span><br><span class="line"><span class="keyword">return</span> i + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>在<code>PARTITION</code>的最后两行中，通过将主元与最左的大于x的元素进行交换，就可以将主元移动到它在数组中的正确位置上，并返回主元的新下标。<br><code>PARTITION</code>在子数组A[p..r]上的时间复杂度是<code>O(n)</code>,其中<code>n=r-p+1</code>。</p>
<p>C++代码实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">    &gt; File Name: quick_sort.cpp</span></span><br><span class="line"><span class="comment">    &gt; Author: qiaoyihan</span></span><br><span class="line"><span class="comment">    &gt; Email: yihqiao@126.com</span></span><br><span class="line"><span class="comment">    &gt; Created Time: Sun Aug  7 16:29:48 2016</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> QuickSort::swap(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> QuickSort::quick_sort(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> q = partition(A, left, right);	</span><br><span class="line">        quick_sort(A, left, q - <span class="number">1</span>);</span><br><span class="line">        quick_sort(A, q + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> QuickSort::partition(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> x = A[right];</span><br><span class="line">    <span class="keyword">int</span> i = left - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = left; j &lt; right; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[j] &lt;= x) &#123;</span><br><span class="line">            i = i + <span class="number">1</span>;</span><br><span class="line">            swap(A[i], A[j]);</span><br><span class="line">        &#125;	</span><br><span class="line">    &#125;</span><br><span class="line">    swap(A[i + <span class="number">1</span>], A[right]);</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> QuickSort::quick_sort(<span class="keyword">int</span> A[], <span class="keyword">int</span> n) </span><br><span class="line">&#123;</span><br><span class="line">    quick_sort(A, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[] = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">38</span>, <span class="number">7</span>, <span class="number">19</span>, <span class="number">8</span>, <span class="number">27</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    QuickSort *pQuickSort = <span class="keyword">new</span> QuickSort();</span><br><span class="line">    pQuickSort-&gt;quick_sort(A, n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> e : A) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="string">" "</span>;	</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>  </p>
<p>在讨论快速排序的平均性能时，我们假设输入序列的所有排列都是等概率的，这个假设并不总是成立，很多人都选择随机化版本的快速排序作为大数据输入情况下的排序算法。</p>
<p>在随机化的快速排序算法中，我们只需要在随机选择了枢轴元素后，把数组的最后一个元素和枢轴元素交换，这样的话我们就又可以利用上面的算法了。</p>
<h4 id="4-1-3-Hoare-partition-scheme"><a href="#4-1-3-Hoare-partition-scheme" class="headerlink" title="4.1.3 Hoare partition scheme"></a>4.1.3 <a href="https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme" target="_blank" rel="noopener">Hoare partition scheme</a></h4><p>The original partition scheme described by C.A.R. Hoare uses two indices that start at the ends of the array being partitioned, then move toward each other, until they detect an inversion: a pair of elements, one greater than the pivot, one smaller, that are in the wrong order relative to each other. The inverted elements are then swapped. When the indices meet, the algorithm stops and returns the final index. There are many variants of this algorithm, for example, selecting pivot from A[hi] instead of A[lo]. <strong>Hoare’s scheme is more efficient than Lomuto’s partition scheme because it does three times fewer swaps on average, and it creates efficient partitions even when all values are equal.</strong> Like Lomuto’s partition scheme, Hoare partitioning also causes Quicksort to degrade to O(n^2) when the input array is already sorted; it also doesn’t produce a stable sort. <strong>Note that in this scheme, the pivot’s final location is not necessarily at the index that was returned</strong>, and the next two segments that the main algorithm recurs on are [lo..p] and (p..hi] as opposed to [lo..p) and (p..hi] as in Lomuto’s scheme. In pseudocode,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">algorithm quicksort(A, lo, hi) is</span><br><span class="line">    if lo &lt; hi then</span><br><span class="line">        p := partition(A, lo, hi)</span><br><span class="line">        quicksort(A, lo, p)</span><br><span class="line">        quicksort(A, p + 1, hi)</span><br><span class="line"></span><br><span class="line">algorithm partition(A, lo, hi) is</span><br><span class="line">    pivot := A[lo]</span><br><span class="line">    i := lo – 1</span><br><span class="line">    j := hi + 1</span><br><span class="line">    loop forever</span><br><span class="line">        do</span><br><span class="line">            i := i + 1</span><br><span class="line">        while A[i] &lt; pivot</span><br><span class="line">        </span><br><span class="line">        do</span><br><span class="line">            j := j – 1</span><br><span class="line">        while A[j] &gt; pivot</span><br><span class="line">        </span><br><span class="line">        if i &gt;= j then</span><br><span class="line">            return j</span><br><span class="line">        </span><br><span class="line">        swap A[i] with A[j]</span><br></pre></td></tr></table></figure>

<p>C++代码实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> QuickSort::swap(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> QuickSort::quick_sort(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> p = partition(A, left, right);	</span><br><span class="line">        quick_sort(A, left, p);</span><br><span class="line">        quick_sort(A, p + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> QuickSort::partition(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = A[left];</span><br><span class="line">    <span class="keyword">int</span> i = left - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = right + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            i = i + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span>(A[i] &lt; pivot);	</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            j = j - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span>(A[j] &gt; pivot);	</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i &gt;= j)</span><br><span class="line">            <span class="keyword">return</span> j;</span><br><span class="line"></span><br><span class="line">        swap(A[i], A[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> QuickSort::quick_sort(<span class="keyword">int</span> A[], <span class="keyword">int</span> n) </span><br><span class="line">&#123;</span><br><span class="line">    quick_sort(A, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[] = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">38</span>, <span class="number">7</span>, <span class="number">19</span>, <span class="number">8</span>, <span class="number">27</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    QuickSort *pQuickSort = <span class="keyword">new</span> QuickSort();</span><br><span class="line">    pQuickSort-&gt;quick_sort(A, n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> e : A) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="string">" "</span>;	</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<p>上面提到的 Hoare partition scheme 和 Lomuto partition scheme 的算法在改变了枢轴元素的位置后，算法的代码要做相应的改变，比较简单的做法是，像快排的随机化版本那样，交换枢轴元素到第一个或最后一个元素的位置处。下面是 Hoare partition scheme 算法的一个变体，该算法较易明白，而且用元素的赋值代替了交换操作，如果取枢轴元素为最后一个的话，需要先从<code>low</code>考虑小于枢轴元素的情况，再从<code>high</code>考虑大于枢轴元素的情况。如果取枢轴元素为第一个的话，需要先从<code>high</code>考虑大于枢轴元素的情况，再从<code>low</code>考虑小于枢轴元素的情况。<br>算法的C++实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> low = left;</span><br><span class="line">        <span class="keyword">int</span> high = right;</span><br><span class="line">        <span class="keyword">int</span> x = A[high];   <span class="comment">// 记录最后一个元素为枢轴元素</span></span><br><span class="line">        <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">while</span>(low &lt; high &amp;&amp; A[low] &lt; x)	</span><br><span class="line">                low++;</span><br><span class="line">            <span class="keyword">if</span>(low &lt; high) &#123;</span><br><span class="line">                A[high] = A[low];</span><br><span class="line">                high--;</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="keyword">while</span>(low &lt; high &amp;&amp; A[high] &gt; x)	</span><br><span class="line">                high--;</span><br><span class="line">            <span class="keyword">if</span>(low &lt; high) &#123;</span><br><span class="line">                A[low] = A[high];</span><br><span class="line">                low++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        A[high] = x;</span><br><span class="line">        quick_sort(A, left, low - <span class="number">1</span>);</span><br><span class="line">        quick_sort(A, low + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    quick_sort(A, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-快速排序的算法复杂度分析"><a href="#4-2-快速排序的算法复杂度分析" class="headerlink" title="4.2 快速排序的算法复杂度分析"></a>4.2 快速排序的算法复杂度分析</h3><table>
<thead>
<tr>
<th align="left">Data structure</th>
<th align="left">Array</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Best case performance</td>
<td align="left">O(n log n) (simple partition) or O(n) (three-way partition and equal keys)</td>
</tr>
<tr>
<td align="left">Worst case performance</td>
<td align="left">O(n^2)</td>
</tr>
<tr>
<td align="left">Average case performance</td>
<td align="left">O(n log n)</td>
</tr>
<tr>
<td align="left">Worst case space complexity</td>
<td align="left">O(n) auxiliary (naive), O(log n) auxiliary (Sedgewick 1978)</td>
</tr>
</tbody></table>
<h2 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5. 归并排序"></a>5. 归并排序</h2><p><strong>Definition</strong>: A sort algorithm that splits the items to be sorted into two groups, recursively sorts each group, and merges them into a final, sorted sequence. Run time is Θ(n log n).</p>
<p>Conceptually, a merge sort works as follows:</p>
<p>1) Divide the unsorted list into n sublists, each containing 1 element (a list of 1 element is considered sorted).</p>
<p>2) Repeatedly merge sublists to produce new sorted sublists until there is only 1 sublist remaining. This will be the sorted list.</p>
<h3 id="5-1-算法的伪代码描述"><a href="#5-1-算法的伪代码描述" class="headerlink" title="5.1 算法的伪代码描述"></a>5.1 算法的伪代码描述</h3><p>归并排序的的关键是合并两个已经排好序的数组，假设子数组<code>A[p ... q]</code>和<code>A[q+1 ... r]</code>已经排好序，下面的算法是合并这两个子数组及归并排序。<br>这里的伪代码为算法导论一书中的归并排序算法改进而来。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">MERGE(A, p, q, r)</span><br><span class="line">n1 = q - p + <span class="number">1</span></span><br><span class="line">n2 = r - q</span><br><span class="line">let L[<span class="number">1.</span>..n1 + <span class="number">1</span>] <span class="keyword">and</span> R[<span class="number">1.</span>..n2 + <span class="number">1</span>] be <span class="keyword">new</span> arrays</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span> to n1</span><br><span class="line">    L[i] = A[p + i - <span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> j = <span class="number">1</span> to n2</span><br><span class="line">    R[j] = A[q + j]</span><br><span class="line">i = <span class="number">1</span></span><br><span class="line">j = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> k = p to r</span><br><span class="line">    <span class="keyword">if</span> i &lt; n1 + <span class="number">1</span> <span class="keyword">and</span> j &lt; n2 + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> L[i] &lt;= R[j]</span><br><span class="line">            A[k] = L[i]</span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            A[k] = R[j]</span><br><span class="line">            j = j + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> i &lt; n1 + <span class="number">1</span></span><br><span class="line">        A[k] = L[i]</span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> j &lt; n2 + <span class="number">1</span></span><br><span class="line">            A[k] = R[j]</span><br><span class="line">            j = j + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">MERGE-SORT(A, p, r)</span><br><span class="line"><span class="keyword">if</span> p &lt; r</span><br><span class="line">    q = (p + r) / <span class="number">2</span></span><br><span class="line">    MERGE-SORT(A, p, q)</span><br><span class="line">    MERGE-SORT(A, q + <span class="number">1</span>, r)</span><br><span class="line">    MERGE(A, p, q, r)</span><br></pre></td></tr></table></figure>

<h4 id="维基百科中对归并排序的算法实现："><a href="#维基百科中对归并排序的算法实现：" class="headerlink" title="维基百科中对归并排序的算法实现："></a>维基百科中对归并排序的算法实现：</h4><h5 id="Top-down-implementation"><a href="#Top-down-implementation" class="headerlink" title="Top-down implementation"></a>Top-down implementation</h5><p>Example C-like code using indices for top down merge sort algorithm that recursively splits the list (called runs in this example) into sublists until sublist size is 1, then merges those sublists to produce a sorted list. The copy back step could be avoided if the recursion alternated between two functions so that the direction of the merge corresponds with the level of recursion.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Array A[] has the items to sort; array B[] is a work array.</span></span><br><span class="line">TopDownMergeSort(A[], B[], n)</span><br><span class="line">&#123;</span><br><span class="line">    TopDownSplitMerge(A, <span class="number">0</span>, n, B);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// iBegin is inclusive; iEnd is exclusive (A[iEnd] is not in the set).</span></span><br><span class="line">TopDownSplitMerge(A[], iBegin, iEnd, B[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(iEnd - iBegin &lt; <span class="number">2</span>)                       <span class="comment">// if run size == 1</span></span><br><span class="line">        <span class="keyword">return</span>;                                 <span class="comment">//   consider it sorted</span></span><br><span class="line">    <span class="comment">// recursively split runs into two halves until run size == 1,</span></span><br><span class="line">    <span class="comment">// then merge them and return back up the call chain</span></span><br><span class="line">    iMiddle = (iEnd + iBegin) / <span class="number">2</span>;              <span class="comment">// iMiddle = mid point</span></span><br><span class="line">    TopDownSplitMerge(A, iBegin,  iMiddle, B);  <span class="comment">// split / merge left  half</span></span><br><span class="line">    TopDownSplitMerge(A, iMiddle,    iEnd, B);  <span class="comment">// split / merge right half</span></span><br><span class="line">    TopDownMerge(A, iBegin, iMiddle, iEnd, B);  <span class="comment">// merge the two half runs</span></span><br><span class="line">    CopyArray(B, iBegin, iEnd, A);              <span class="comment">// copy the merged runs back to A</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Left half is A[iBegin:iMiddle-1].</span></span><br><span class="line"><span class="comment">// Right half is A[iMiddle:iEnd-1   ].</span></span><br><span class="line">TopDownMerge(A[], iBegin, iMiddle, iEnd, B[])</span><br><span class="line">&#123;</span><br><span class="line">    i = iBegin, j = iMiddle;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// While there are elements in the left or right runs...</span></span><br><span class="line">    <span class="keyword">for</span> (k = iBegin; k &lt; iEnd; k++) &#123;</span><br><span class="line">        <span class="comment">// If left run head exists and is &lt;= existing right run head.</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; iMiddle &amp;&amp; (j &gt;= iEnd || A[i] &lt;= A[j])) &#123;</span><br><span class="line">            B[k] = A[i];</span><br><span class="line">            i = i + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            B[k] = A[j];</span><br><span class="line">            j = j + <span class="number">1</span>;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CopyArray(B[], iBegin, iEnd, A[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(k = iBegin; k &lt; iEnd; k++)</span><br><span class="line">        A[k] = B[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Bottom-up-implementation"><a href="#Bottom-up-implementation" class="headerlink" title="Bottom-up implementation"></a>Bottom-up implementation</h5><p>Example C-like code using indices for bottom up merge sort algorithm which treats the list as an array of n sublists (called runs in this example) of size 1, and iteratively merges sub-lists back and forth between two buffers:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array A[] has the items to sort; array B[] is a work array</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BottomUpMergeSort</span><span class="params">(A[], B[], n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// Each 1-element run in A is already "sorted".</span></span><br><span class="line">  <span class="comment">// Make successively longer sorted runs of length 2, 4, 8, 16... until whole array is sorted.</span></span><br><span class="line">  <span class="keyword">for</span> (width = <span class="number">1</span>; width &lt; n; width = <span class="number">2</span> * width)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// Array A is full of runs of length width.</span></span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i = i + <span class="number">2</span> * width)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// Merge two runs: A[i:i+width-1] and A[i+width:i+2*width-1] to B[]</span></span><br><span class="line">          <span class="comment">// or copy A[i:n-1] to B[] ( if(i+width &gt;= n) )</span></span><br><span class="line">          BottomUpMerge(A, i, min(i+width, n), min(i+<span class="number">2</span>*width, n), B);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// Now work array B is full of runs of length 2*width.</span></span><br><span class="line">      <span class="comment">// Copy array B to array A for next iteration.</span></span><br><span class="line">      <span class="comment">// A more efficient implementation would swap the roles of A and B.</span></span><br><span class="line">      CopyArray(B, A, n);</span><br><span class="line">      <span class="comment">// Now array A is full of runs of length 2*width.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Left run is A[iLeft :iRight-1].</span></span><br><span class="line"><span class="comment">// Right run is A[iRight:iEnd-1  ].</span></span><br><span class="line">BottomUpMerge(A[], iLeft, iRight, iEnd, B[])</span><br><span class="line">&#123;</span><br><span class="line">    i = iLeft, j = iRight;</span><br><span class="line">    <span class="comment">// While there are elements in the left or right runs...</span></span><br><span class="line">    <span class="keyword">for</span> (k = iLeft; k &lt; iEnd; k++) &#123;</span><br><span class="line">        <span class="comment">// If left run head exists and is &lt;= existing right run head.</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; iRight &amp;&amp; (j &gt;= iEnd || A[i] &lt;= A[j])) &#123;</span><br><span class="line">            B[k] = A[i];</span><br><span class="line">            i = i + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            B[k] = A[j];</span><br><span class="line">            j = j + <span class="number">1</span>;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CopyArray</span><span class="params">(B[], A[], n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        A[i] = B[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Top-down-implementation-using-lists"><a href="#Top-down-implementation-using-lists" class="headerlink" title="Top-down implementation using lists"></a>Top-down implementation using lists</h5><p>Pseudocode for top down merge sort algorithm which recursively divides the input list into smaller sublists until the sublists are trivially sorted, and then merges the sublists while returning up the call chain.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function merge_sort(list m)</span><br><span class="line">    // Base case. A list of zero or one elements is sorted, by definition.</span><br><span class="line">    if length of m ≤ 1 then</span><br><span class="line">        return m</span><br><span class="line"></span><br><span class="line">    // Recursive case. First, divide the list into equal-sized sublists</span><br><span class="line">    // consisting of the even and odd-indexed elements.</span><br><span class="line">    var left := empty list</span><br><span class="line">    var right := empty list</span><br><span class="line">    for each x with index i in m do</span><br><span class="line">        if i is odd then</span><br><span class="line">            add x to left</span><br><span class="line">        else</span><br><span class="line">            add x to right</span><br><span class="line"></span><br><span class="line">    // Recursively sort both sublists.</span><br><span class="line">    left := merge_sort(left)</span><br><span class="line">    right := merge_sort(right)</span><br><span class="line"></span><br><span class="line">    // Then merge the now-sorted sublists.</span><br><span class="line">    return merge(left, right)</span><br></pre></td></tr></table></figure>

<p>In this example, the merge function merges the left and right sublists.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function merge(left, right)</span><br><span class="line">    var result := empty list</span><br><span class="line"></span><br><span class="line">    while left is not empty and right is not empty do</span><br><span class="line">        if first(left) ≤ first(right) then</span><br><span class="line">            append first(left) to result</span><br><span class="line">            left := rest(left)</span><br><span class="line">        else</span><br><span class="line">            append first(right) to result</span><br><span class="line">            right := rest(right)</span><br><span class="line"></span><br><span class="line">    // Either left or right may have elements left; consume them.</span><br><span class="line">    // (Only one of the following loops will actually be entered.)</span><br><span class="line">    while left is not empty do</span><br><span class="line">        append first(left) to result</span><br><span class="line">        left := rest(left)</span><br><span class="line">    while right is not empty do</span><br><span class="line">        append first(right) to result</span><br><span class="line">        right := rest(right)</span><br><span class="line">    return result</span><br></pre></td></tr></table></figure>

<h5 id="Bottom-up-implementation-using-lists"><a href="#Bottom-up-implementation-using-lists" class="headerlink" title="Bottom-up implementation using lists"></a>Bottom-up implementation using lists</h5><p>Pseudocode for bottom up merge sort algorithm which uses a small fixed size array of references to nodes, where array[i] is either a reference to a list of size 2^i or 0. node is a reference or pointer to a node. The merge() function would be similar to the one shown in the top down merge lists example, it merges two already sorted lists, and handles empty lists. In this case, merge() would use node for its input parameters and return value.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function merge_sort(node head)</span><br><span class="line">    // return if empty list</span><br><span class="line">    if (head == nil)</span><br><span class="line">        return nil</span><br><span class="line">    var node array[32]; initially all nil</span><br><span class="line">    var node result</span><br><span class="line">    var node next</span><br><span class="line">    var int  i</span><br><span class="line">    result = head</span><br><span class="line">    // merge nodes into array</span><br><span class="line">    while (result != nil)</span><br><span class="line">         next = result.next;</span><br><span class="line">         result.next = nil</span><br><span class="line">         for(i = 0; (i &lt; 32) &amp;&amp; (array[i] != nil); i += 1)</span><br><span class="line">              result = merge(array[i], result)</span><br><span class="line">              array[i] = nil</span><br><span class="line">         // do not go past end of array</span><br><span class="line">         if (i == 32)</span><br><span class="line">               i -= 1</span><br><span class="line">         array[i] = result</span><br><span class="line">         result = next</span><br><span class="line">    // merge array into single list</span><br><span class="line">    result = nil</span><br><span class="line">    for (i = 0; i &lt; 32; i += 1)</span><br><span class="line">         result = merge(array[i], result)</span><br><span class="line">    return result</span><br></pre></td></tr></table></figure>

<h3 id="5-2-算法复杂度分析"><a href="#5-2-算法复杂度分析" class="headerlink" title="5.2 算法复杂度分析"></a>5.2 算法复杂度分析</h3><table>
<thead>
<tr>
<th align="left">Data structure</th>
<th align="left">Array</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Best case performance</td>
<td align="left">O(n log n) typical, O(n) natural variant</td>
</tr>
<tr>
<td align="left">Worst case performance</td>
<td align="left">O(n log n)</td>
</tr>
<tr>
<td align="left">Average case performance</td>
<td align="left">O(n log n)</td>
</tr>
<tr>
<td align="left">Worst case space complexity</td>
<td align="left">О(n) total, O(n) auxiliary</td>
</tr>
</tbody></table>
<h3 id="5-3-和其他排序算法的比较："><a href="#5-3-和其他排序算法的比较：" class="headerlink" title="5.3 和其他排序算法的比较："></a>5.3 和其他排序算法的比较：</h3><p>Although heapsort has the same time bounds as merge sort, it requires only Θ(1) auxiliary space instead of merge sort’s Θ(n). On typical modern architectures, efficient quicksort implementations generally outperform mergesort for sorting RAM-based arrays.[citation needed] On the other hand, merge sort is a stable sort and is more efficient at handling slow-to-access sequential media. Merge sort is often the best choice for sorting a linked list: in this situation it is relatively easy to implement a merge sort in such a way that it requires only Θ(1) extra space, and the slow random-access performance of a linked list makes some other algorithms (such as quicksort) perform poorly, and others (such as heapsort) completely impossible.</p>
<p>As of Perl 5.8, merge sort is its default sorting algorithm (it was quicksort in previous versions of Perl). In Java, the Arrays.sort() methods use merge sort or a tuned quicksort depending on the datatypes and for implementation efficiency switch to insertion sort when fewer than seven array elements are being sorted. Python uses Timsort, another tuned hybrid of merge sort and insertion sort, that has become the standard sort algorithm in Java SE 7, on the Android platform, and in GNU Octave.</p>
<h3 id="5-4-归并排序图例演示"><a href="#5-4-归并排序图例演示" class="headerlink" title="5.4 归并排序图例演示"></a>5.4 归并排序图例演示</h3><p><img src="http://img.blog.csdn.net/20160517150920429" alt="image"></p>
<h3 id="5-5-对链表归并排序的示例"><a href="#5-5-对链表归并排序的示例" class="headerlink" title="5.5 对链表归并排序的示例"></a>5.5 对链表归并排序的示例</h3><h5 id="合并两个有序的链表"><a href="#合并两个有序的链表" class="headerlink" title="合并两个有序的链表"></a>合并两个有序的链表</h5><p>要求：使用常量的额外空间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/********************************************************************************** </span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* Merge two sorted linked lists and return it as a new list. The new list should be </span></span><br><span class="line"><span class="comment">* made by splicing together the nodes of the first two lists.</span></span><br><span class="line"><span class="comment">*               </span></span><br><span class="line"><span class="comment">**********************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Solution()&#123;</span><br><span class="line">        srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode *<span class="title">mergeTwoLists</span><span class="params">(ListNode *l1, ListNode *l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (random()%<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> mergeTwoLists01(l1, l2);</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> mergeTwoLists02(l1, l2);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> mergeTwoLists03(l1, l2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* merge the 2nd list into 1st list*/</span></span><br><span class="line">    <span class="function">ListNode *<span class="title">mergeTwoLists01</span><span class="params">(ListNode* head1, ListNode* head2)</span></span>&#123;</span><br><span class="line">        ListNode *p1 = head1,  *p2=head2;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> ListNode <span class="title">dummy</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">        dummy.next = p1;</span><br><span class="line">        ListNode *prev = &amp;dummy;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span>(p1 &amp;&amp; p2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p1-&gt;val &lt; p2-&gt;val)&#123;</span><br><span class="line">                prev = p1;</span><br><span class="line">                p1 = p1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                prev-&gt;next = p2;</span><br><span class="line">                p2 = p2-&gt;next;</span><br><span class="line">                prev = prev-&gt;next;</span><br><span class="line">                prev-&gt;next = p1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p2)&#123;</span><br><span class="line">            prev-&gt;next = p2;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* merge two lists to the new list */</span></span><br><span class="line">    <span class="function">ListNode *<span class="title">mergeTwoLists02</span><span class="params">(ListNode *l1, ListNode *l2)</span> </span>&#123;</span><br><span class="line">        ListNode *l=<span class="literal">NULL</span>, *p=<span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (l1!=<span class="literal">NULL</span> &amp;&amp; l2!=<span class="literal">NULL</span> )&#123;</span><br><span class="line">            ListNode *n=<span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt; val)&#123;</span><br><span class="line">                n = l1;</span><br><span class="line">                l1=l1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                n = l2;</span><br><span class="line">                l2=l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l==<span class="literal">NULL</span>)&#123;</span><br><span class="line">                l = p = n;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p-&gt;next = n;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode* rest = l1 ? l1 :l2;</span><br><span class="line">        </span><br><span class="line">        l = mergeTheRest(rest, l, p);</span><br><span class="line">       </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTheRest</span><span class="params">(ListNode* l, ListNode*head, ListNode* tail)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l)&#123;</span><br><span class="line">            <span class="keyword">if</span> (head &amp;&amp; tail )&#123;</span><br><span class="line">                tail-&gt;next = l;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                head = l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  </span></span><br><span class="line"><span class="comment">     * You can see the 2nd slution's code is quite complicated, </span></span><br><span class="line"><span class="comment">     * because it need to check the (head==NULL) situation.</span></span><br><span class="line"><span class="comment">     * We can use the "pointer to pointer" to make the code more clean</span></span><br><span class="line"><span class="comment">     * however, this would be bad for performance.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ListNode *<span class="title">mergeTwoLists03</span><span class="params">(ListNode *l1, ListNode *l2)</span> </span>&#123;</span><br><span class="line">        ListNode *head = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode **pTail = &amp;head;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">NULL</span> &amp;&amp; l2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">                *pTail = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                *pTail = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            pTail = &amp;(*pTail)-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        *pTail = (l1 != <span class="literal">NULL</span> ? l1 : l2);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="使用归并排序对链表进行排序"><a href="#使用归并排序对链表进行排序" class="headerlink" title="使用归并排序对链表进行排序"></a>使用归并排序对链表进行排序</h5><h6 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mergeSort(head);    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeSort</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">            </span><br><span class="line">        <span class="function">ListNode <span class="title">dummy1</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">ListNode <span class="title">dummy2</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        ListNode *left = &amp;dummy1;</span><br><span class="line">        ListNode *right = &amp;dummy2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i++ % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                left-&gt;next = head;</span><br><span class="line">                left = left-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right-&gt;next = head;</span><br><span class="line">                right = right-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        left-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        right-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        left = dummy1.next;</span><br><span class="line">        right = dummy2.next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* left, ListNode* right)</span> </span>&#123;</span><br><span class="line">        ListNode *p1 = left, *p2 = right;</span><br><span class="line">        <span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        ListNode *tail = &amp;dummy;</span><br><span class="line">        <span class="keyword">while</span>(p1 &amp;&amp; p2) &#123;</span><br><span class="line">            <span class="keyword">if</span>(p1-&gt;val &lt; p2-&gt;val) &#123;</span><br><span class="line">                tail-&gt;next = p1;</span><br><span class="line">                p1 = p1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail-&gt;next = p2;</span><br><span class="line">                p2 = p2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p1) tail-&gt;next = p1;</span><br><span class="line">        <span class="keyword">if</span>(p2) tail-&gt;next = p2;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h6 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/********************************************************************************** </span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* Sort a linked list in O(n log n) time using constant space complexity.</span></span><br><span class="line"><span class="comment">*               </span></span><br><span class="line"><span class="comment">**********************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode *<span class="title">mergeTwoLists</span><span class="params">(ListNode* head1, ListNode* head2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode *<span class="title">sortList</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head==<span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//find the middle place</span></span><br><span class="line">    ListNode *p1=head, *p2=head-&gt;next; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p2 &amp;&amp; p2-&gt;next)&#123;</span><br><span class="line">        p1 = p1-&gt;next;</span><br><span class="line">        p2 = p2-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    p2 = p1-&gt;next;</span><br><span class="line">    p1-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> mergeTwoLists(sortList(head), sortList(p2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">ListNode *<span class="title">mergeTwoLists</span><span class="params">(ListNode* head1, ListNode* head2)</span></span>&#123;</span><br><span class="line">    ListNode *p1 = head1,  *p2=head2;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> ListNode <span class="title">dummy</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    ListNode *tail = &amp;dummy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p1 &amp;&amp; p2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p1-&gt;val &lt; p2-&gt;val)&#123;</span><br><span class="line">            tail-&gt;next = p1;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            tail-&gt;next = p2;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = tail-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p1) tail-&gt;next = p1;</span><br><span class="line">    <span class="keyword">if</span> (p2) tail-&gt;next = p2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-选择排序"><a href="#6-选择排序" class="headerlink" title="6. 选择排序"></a>6. 选择排序</h2><p>In computer science, selection sort is a sorting algorithm, specifically an in-place comparison sort. It has O(n^2) time complexity, making it inefficient on large lists, and generally performs worse than the similar insertion sort. Selection sort is noted for its simplicity, and it has performance advantages over more complicated algorithms in certain situations, particularly where auxiliary memory is limited.</p>
<p>The algorithm divides the input list into two parts: the sublist of items already sorted, which is built up from left to right at the front (left) of the list, and the sublist of items remaining to be sorted that occupy the rest of the list. Initially, the sorted sublist is empty and the unsorted sublist is the entire input list. The algorithm proceeds by finding the smallest (or largest, depending on sorting order) element in the unsorted sublist, exchanging (swapping) it with the leftmost unsorted element (putting it in sorted order), and moving the sublist boundaries one element to the right.</p>
<h3 id="6-1-实现"><a href="#6-1-实现" class="headerlink" title="6.1 实现"></a>6.1 实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* a[0] to a[n-1] is the array to sort */</span></span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* advance the position through the entire array */</span></span><br><span class="line"><span class="comment">/*   (could do j &lt; n-1 because single element is also min element) */</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n<span class="number">-1</span>; j++) &#123;</span><br><span class="line">    <span class="comment">/* find the min element in the unsorted a[j .. n-1] */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* assume the min is the first element */</span></span><br><span class="line">    <span class="keyword">int</span> iMin = j;</span><br><span class="line">    <span class="comment">/* test against elements after j to find the smallest */</span></span><br><span class="line">    <span class="keyword">for</span> ( i = j+<span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">/* if this element is less, then it is the new minimum */</span></span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; a[iMin]) &#123;</span><br><span class="line">            <span class="comment">/* found new minimum; remember its index */</span></span><br><span class="line">            iMin = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(iMin != j) &#123;</span><br><span class="line">        swap(a[j], a[iMin]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-2-分析"><a href="#6-2-分析" class="headerlink" title="6.2 分析"></a>6.2 分析</h3><p>Selection sort is not difficult to analyze compared to other sorting algorithms since none of the loops depend on the data in the array. Selecting the lowest element requires scanning all n elements (this takes n − 1 comparisons) and then swapping it into the first position. Finding the next lowest element requires scanning the remaining n − 1 elements and so on, for (n − 1) + (n − 2) + … + 2 + 1 = n(n - 1) / 2 ∈ Θ(n^2) comparisons (see arithmetic progression).[1] Each of these scans requires one swap for n − 1 elements (the final element is already in place).</p>
<h3 id="6-3-选择排序演示"><a href="#6-3-选择排序演示" class="headerlink" title="6.3 选择排序演示"></a>6.3 选择排序演示</h3><p><img src="https://upload.wikimedia.org/wikipedia/commons/9/94/Selection-Sort-Animation.gif" alt="image"><br>Selection sort animation. Red is current min. Yellow is sorted list. Blue is current item.</p>
<h2 id="7-堆排序"><a href="#7-堆排序" class="headerlink" title="7. 堆排序"></a>7. 堆排序</h2><p>In computer science, heapsort is a comparison-based sorting algorithm. Heapsort can be thought of as an improved selection sort: like that algorithm, it divides its input into a sorted and an unsorted region, and it iteratively shrinks the unsorted region by extracting the largest element and moving that to the sorted region. The improvement consists of the use of a heap data structure rather than a linear-time search to find the maximum.</p>
<p>Although somewhat slower in practice on most machines than a well-implemented quicksort, it has the advantage of a more favorable worst-case O(n log n) runtime. <strong>Heapsort is an in-place algorithm, but it is not a stable sort.</strong></p>
<p>The heapsort algorithm can be divided into two parts.</p>
<p>In the first step, a heap is built out of the data. The heap is often placed in an array with the layout of a complete binary tree. The complete binary tree maps the binary tree structure into the array indices; each array index represents a node; the index of the node’s parent, left child branch, or right child branch are simple expressions. For a zero-based array, the root node is stored at index 0; if i is the index of the current node, then</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iParent(i)     = floor((i-1) / 2)</span><br><span class="line">iLeftChild(i)  = 2*i + 1</span><br><span class="line">iRightChild(i) = 2*i + 2</span><br></pre></td></tr></table></figure>

<p>In the second step, a sorted array is created by repeatedly removing the largest element from the heap (the root of the heap), and inserting it into the array. The heap is updated after each removal to maintain the heap. Once all objects have been removed from the heap, the result is a sorted array.</p>
<p>Heapsort can be performed in place. The array can be split into two parts, the sorted array and the heap. The storage of heaps as arrays is diagrammed here. The heap’s invariant is preserved after each extraction, so the only cost is that of extraction.</p>
<h3 id="7-1-实现"><a href="#7-1-实现" class="headerlink" title="7.1 实现"></a>7.1 实现</h3><p><strong>(参考算法导论第3版堆排序一章并有所修改)</strong></p>
<p>二叉堆有两种，最大堆和最小堆（小根堆）。在最大堆中，最大堆的特性是指除了根以外的每个节点<code>i</code>，有<code>A[PARENT(i)] &gt;= A[i]</code>，这样在最大堆中最大的元素在树的根部。最小堆则相反，最小堆的特性是除了根节点以外的每个节点<code>i</code>，有<code>A[PARENT(i)] &lt;= A[i]</code>，这样在最小堆中最小的元素在树的根部。</p>
<p>堆排序的过程：  </p>
<ul>
<li><code>buildMaxHeap()</code>过程，以O(n)时间运行，可以在无序的输入数组基础上构建出最大堆。</li>
<li>交换数组中的第一个元素和最后一个元素，数组中的最大元素被移动到了它的最终位置，待排序的数组长度减少了1.</li>
<li>调用<code>maxHeapify()</code>过程，保持最大堆的性质，使最大的元素在堆的根部，此步骤的时间复杂度是O(log(n))。</li>
<li>重复步骤2直到未排序的数组中的元素个数减少到1。</li>
</ul>
<p>算法的伪代码如下：</p>
<p><code>maxHeapify()</code>是用于维护堆的性质，它的输入为一个数组<code>A</code>和一个下标<code>i</code>，在调用<code>maxHeapify()</code>的时候，我们假定根节点为<code>iLeftChild(i)</code>和<code>iRightChild(i)</code>的二叉树都是最大堆，但这时<code>A[i]</code>有可能小于其孩子，这样就违背了最大堆的性质。<code>maxHeapify()</code>通过让<code>A[i]</code>的值在最大堆中“逐级下降”，从而使得以下标<code>i</code>为根节点的子树重新遵循最大堆的性质。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">maxHeapify(A, i) &#123;</span><br><span class="line">    left = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    right = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> left &lt; A.heap_size <span class="keyword">and</span> A[left] &gt; A[i]</span><br><span class="line">        largest = left;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        largest = i;</span><br><span class="line">    <span class="keyword">if</span> right &lt; A.heap_size <span class="keyword">and</span> A[right] &gt; A[largest]</span><br><span class="line">        largest = right;</span><br><span class="line">    <span class="keyword">if</span> largest != i &#123;</span><br><span class="line">        exchange A[i] with A[largest];</span><br><span class="line">        maxHeapify(A, largest);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于一棵以<code>i</code>为根节点，大小为n的子树，<code>maxHeapify()</code>的时间代价包括：调整<code>A[i]</code>和<code>A[iLeftChild(i)]</code>和<code>A[iRightChild(i)]</code>的关系的时间代价Θ(1),加上在一棵以<code>i</code>的一个孩子为根节点的子树上运行<code>maxHeapify()</code>的时间代价（这里假设递归调用会发生）。因为每个孩子的子树的大小至多为2n/3（最坏情况发生在树的最底层恰好半满的时候），可以用下面的递归式表达运行时间：<br>$T(n) \leq T(2n/3)+\Theta(1)$<br>根据主定理，上述递归式的解为O(logn)。</p>
<p>假设数组的长度为n，则子数组<code>A[(n-1-1)/2+1...n-1]</code>中的元素都是树的叶子节点，每个叶子节点都可以看成只包含一个元素的堆。过程<code>buildMaxHeap()</code>对树中的其他节点都调用一次<code>maxHeapify()</code>。这是一个自底向上的建堆过程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">buildMaxHeap(A) &#123;</span><br><span class="line">    A.heap_size = A.length;</span><br><span class="line">    <span class="keyword">for</span> i = <span class="built_in">floor</span>((A.length - <span class="number">2</span>) / <span class="number">2</span>) downto <span class="number">0</span></span><br><span class="line">        maxHeapify(A, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>堆排序算法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">heapSort(A) &#123;</span><br><span class="line">    buildMaxHeap(A)</span><br><span class="line">    <span class="keyword">for</span> i = A.length - <span class="number">1</span> downto <span class="number">1</span> &#123;</span><br><span class="line">        exchange A[<span class="number">0</span>] with A[i]</span><br><span class="line">        A.heap_size = A.heap_size - <span class="number">1</span></span><br><span class="line">        maxHeapify(A, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-2-和其他排序算法的比较-Comparison-with-other-sorts"><a href="#7-2-和其他排序算法的比较-Comparison-with-other-sorts" class="headerlink" title="7.2 和其他排序算法的比较(Comparison with other sorts)"></a>7.2 和其他排序算法的比较(<a href="https://en.wikipedia.org/wiki/Heapsort#Comparison_with_other_sorts" target="_blank" rel="noopener">Comparison with other sorts</a>)</h3><p>Heapsort primarily competes with quicksort, another very efficient general purpose nearly-in-place comparison-based sort algorithm.</p>
<p>Quicksort is typically somewhat faster due to some factors, but the worst-case running time for quicksort is O(n^2), which is unacceptable for large data sets and can be deliberately triggered given enough knowledge of the implementation, creating a security risk. See quicksort for a detailed discussion of this problem and possible solutions.</p>
<p>Thus, because of the O(n log n) upper bound on heapsort’s running time and constant upper bound on its auxiliary storage, embedded systems with real-time constraints or systems concerned with security often use heapsort.</p>
<p>Heapsort also competes with merge sort, which has the same time bounds. Merge sort requires Ω(n) auxiliary space, but heapsort requires only a constant amount. Heapsort typically runs faster in practice on machines with small or slow data caches, and does not require as much external memory. On the other hand, merge sort has several advantages over heapsort:</p>
<ul>
<li>Merge sort on arrays has considerably better data cache performance, often outperforming heapsort on modern desktop computers because merge sort frequently accesses contiguous memory locations (good locality of reference); heapsort references are spread throughout the heap.</li>
<li>Heapsort is not a stable sort; merge sort is stable.</li>
<li>Merge sort parallelizes well and can achieve close to linear speedup with a trivial implementation; heapsort is not an obvious candidate for a parallel algorithm.</li>
<li>Merge sort can be adapted to operate on singly linked lists with O(1) extra space. Heapsort can be adapted to operate on doubly linked lists with only O(1) extra space overhead.</li>
<li>Merge sort is used in external sorting; heapsort is not. Locality of reference is the issue.</li>
</ul>
<p><a href="https://en.wikipedia.org/wiki/Introsort" target="_blank" rel="noopener">Introsort</a> is an alternative to heapsort that combines quicksort and heapsort to retain advantages of both: worst case speed of heapsort and average speed of quicksort.</p>
<h3 id="7-3-算法复杂度分析"><a href="#7-3-算法复杂度分析" class="headerlink" title="7.3 算法复杂度分析"></a>7.3 算法复杂度分析</h3><table>
<thead>
<tr>
<th align="left">Data structure</th>
<th align="left">Array</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Best case performance</td>
<td align="left">O(n log n), Ω(n)</td>
</tr>
<tr>
<td align="left">Worst case performance</td>
<td align="left">O(n log n)</td>
</tr>
<tr>
<td align="left">Average case performance</td>
<td align="left">O(n log n)</td>
</tr>
<tr>
<td align="left">Worst case space complexity</td>
<td align="left">O(1) auxiliary</td>
</tr>
</tbody></table>
<h3 id="7-4-堆排序演示"><a href="#7-4-堆排序演示" class="headerlink" title="7.4 堆排序演示"></a>7.4 堆排序演示</h3><p><img src="https://upload.wikimedia.org/wikipedia/commons/4/4d/Heapsort-example.gif" alt="image"></p>
<h3 id="7-5-堆排序的C-代码实现"><a href="#7-5-堆排序的C-代码实现" class="headerlink" title="7.5 堆排序的C++代码实现"></a>7.5 堆排序的C++代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        buildMaxHeap(A, n); </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="built_in">std</span>::swap(A[<span class="number">0</span>], A[i]);</span><br><span class="line">            heap_size--;</span><br><span class="line">            maxHeapify(A, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">maxHeapify</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> left = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">int</span> right = <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line">    	<span class="keyword">int</span> largest = <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">if</span>(left &lt; heap_size &amp;&amp; A[left] &gt; A[index]) &#123;</span><br><span class="line">            largest = left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            largest = index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right &lt; heap_size &amp;&amp; A[right] &gt; A[largest])</span><br><span class="line">            largest = right;</span><br><span class="line">        <span class="keyword">if</span>(largest != index) &#123;</span><br><span class="line">        	<span class="built_in">std</span>::swap(A[index], A[largest]);</span><br><span class="line">        	maxHeapify(A, largest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    	heap_size = n;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = (n - <span class="number">2</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            maxHeapify(A, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> heap_size = <span class="number">0</span>;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[] = &#123;<span class="number">9</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">19</span>, <span class="number">8</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    HeapSort h;</span><br><span class="line">    h.heapSort(A, n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> e : A) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="string">"  "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Reference Links：<br><a href="http://blog.csdn.net/xiazdong/article/details/8462393" target="_blank" rel="noopener">九大排序算法再总结</a><br><a href="http://blog.csdn.net/amazing7/article/details/51603682" target="_blank" rel="noopener">九大基础排序总结与对比</a><br><a href="http://blog.csdn.net/xiazdong/article/details/7304239" target="_blank" rel="noopener">数据结构复习之【排序】</a><br><a href="http://blog.csdn.net/hguisu/article/details/7776068" target="_blank" rel="noopener">八大排序算法</a><br><a href="https://en.wikipedia.org/wiki/Sorting_algorithm" target="_blank" rel="noopener">Sorting algorithm</a><br><a href="http://www.cs.wcupa.edu/rkline/ds/shell-comparison.html" target="_blank" rel="noopener">希尔排序</a>  </p>
<p>排序算法视频演示：<br><a href="http://www.bilibili.com/video/av685670/" target="_blank" rel="noopener">http://www.bilibili.com/video/av685670/</a><br><a href="http://airtucha.github.io/SortVis/" target="_blank" rel="noopener">http://airtucha.github.io/SortVis/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://evanqiao.github.io/xiaojn-blog/2016/08/25/典型排序算法回顾/" data-id="cjxbtu1ob001fqo67qcxzpdpq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/xiaojn-blog/tags/Algorithm/">Algorithm</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-刷编程竞赛类题目的一些小技巧" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/xiaojn-blog/2016/07/10/刷编程竞赛类题目的一些小技巧/" class="article-date">
  <time datetime="2016-07-10T12:03:35.000Z" itemprop="datePublished">2016-07-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/xiaojn-blog/categories/算法/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/xiaojn-blog/2016/07/10/刷编程竞赛类题目的一些小技巧/">刷编程竞赛类题目的一些小技巧</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="包含头文件"><a href="#包含头文件" class="headerlink" title="包含头文件"></a>包含头文件</h2><h3 id="LeetCode类型的题目"><a href="#LeetCode类型的题目" class="headerlink" title="LeetCode类型的题目"></a>LeetCode类型的题目</h3><p>LeetCode网站的题目的特点：</p>
<ul>
<li>给出了函数原型，只要在函数体里补充代码即可</li>
<li>使用C++语言时，不需要包含头文件，不需要<code>using std</code>里面的类或变量</li>
<li>使用Java或Python等语言时，也不需要<code>import package</code></li>
<li>算法的输出一般通过<code>return</code>给出，不需要打印</li>
</ul>
<h3 id="HihoCoder类型的题目"><a href="#HihoCoder类型的题目" class="headerlink" title="HihoCoder类型的题目"></a>HihoCoder类型的题目</h3><p>这种oj类型的题目，需要写出完整的代码，包含头文件（C/C++），导入用到的包（Java、Python）,而且要用完整的输入和输出。<br>为了编写代码的快速性，通常会把需要用到的头文件、宏定义、类型定义等事先写出来，在做题的时候直接拷贝，下面的是常用的头文件和宏定义等。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP(a, b) make_pair(a, b)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PB(a) push_back(a)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>,<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; puu;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt; pid;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, <span class="keyword">int</span>&gt; pli;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, ll&gt; pil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="title">class</span> <span class="title">U</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">Max</span>(<span class="title">T</span> &amp;<span class="title">a</span>,<span class="title">U</span> <span class="title">b</span>)&#123;</span><span class="keyword">if</span>(a &lt; b) a = b;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="title">class</span> <span class="title">U</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">Min</span>(<span class="title">T</span> &amp;<span class="title">a</span>,<span class="title">U</span> <span class="title">b</span>)&#123;</span><span class="keyword">if</span>(a &gt; b) a = b;&#125;</span><br></pre></td></tr></table></figure>

<p>第19行代码把<code>int</code>类型的无限大设置为<code>0x3f3f3f3f</code>,<code>0x3f3f3f3f</code>的十进制是<code>1061109567</code>，是10^9级别的（和0x7fffffff一个数量级），而一般场合下的数据都是小于10^9的，所以它可以作为无穷大使用而不致出现数据大于无穷大的情形。<br>另一方面，由于一般的数据都不会大于10^9，所以当我们把无穷大加上一个数据时，它并不会溢出（这就满足了“无穷大加一个有穷的数依然是无穷大”），事实上<code>0x3f3f3f3f + 0x3f3f3f3f=2122219134</code>，这非常大但却没有超过32-bit int的表示范围，所以<code>0x3f3f3f3f</code>还满足了我们“无穷大加无穷大还是无穷大”的需求。<br>最后，<code>0x3f3f3f3f</code>还能给我们带来一个意想不到的额外好处：<br>如果我们想要将某个数组清零，我们通常会使用<code>memset(a,0,sizeof(a))</code>，方便又高效，但是当我们想将某个数组全部赋值为无穷大时，就不能使用memset函数而得自己写循环了，因为memset是按字节操作的，它能够对数组清零是因为0的每个字节都是0（一般我们只有赋值为-1和0的时候才使用它）。现在好了，如果我们将无穷大设为<code>0x3f3f3f3f</code>，那么奇迹就发生了，<code>0x3f3f3f3f</code>的每个字节都是<code>0x3f</code>！所以要把一段内存全部置为无穷大，我们只需要<code>memset(a,0x3f,sizeof(a))</code>。</p>
<h2 id="万能头文件"><a href="#万能头文件" class="headerlink" title="万能头文件"></a>万能头文件</h2><p><code>#include&lt;bits/stdc++.h&gt;</code>这个头文件包含了C++的所有头文件，为了方便，可以直接包含这个头文件。不过有的编译器可能不支持，这个需要注意。</p>
<h2 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h2><p>LeetCode类型的题目不需要用户关注输入和输出，而HihoCoder类型的题目需要用户写出完整的输入和输出格式。一般的格式如下：<br>C语言：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b) != EOF) &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a + b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C++语言：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b) &#123;</span><br><span class="line">    	<span class="built_in">cout</span> &lt;&lt; a + b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java语言：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">	</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(in.hasNext()) &#123;</span><br><span class="line">        	<span class="keyword">int</span> a = in.nextInt();</span><br><span class="line">        	<span class="keyword">int</span> b = in.nextInt();</span><br><span class="line">        	System.out.println(a + b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C#语言：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">	</span><br><span class="line">using System;</span><br><span class="line"></span><br><span class="line">public class AplusB</span><br><span class="line">&#123;</span><br><span class="line">    private static void Main()</span><br><span class="line">    &#123;</span><br><span class="line">        string line;</span><br><span class="line">        while((line = Console.ReadLine()) != null)</span><br><span class="line">        &#123;</span><br><span class="line">            string[] tokens = line.Split(&apos; &apos;);</span><br><span class="line">            Console.WriteLine(int.Parse(tokens[0]) + int.Parse(tokens[1]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Python2语言：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">	</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        (x, y) = (int(x) <span class="keyword">for</span> x <span class="keyword">in</span> raw_input().split())</span><br><span class="line">        <span class="keyword">print</span> x + y</span><br><span class="line">    <span class="keyword">except</span> EOFError:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p>特别地，对于Google apac test这样的竞赛题目，输入和输出要求在文件中，那么需要重定向标准输入和标准输出：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">freopen(<span class="string">"test.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"test.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br></pre></td></tr></table></figure>

<p>Ref:<br><a href="http://blog.csdn.net/jiange_zh/article/details/50198097" target="_blank" rel="noopener">为何程序员喜欢将INF设置为0x3f3f3f3f？</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://evanqiao.github.io/xiaojn-blog/2016/07/10/刷编程竞赛类题目的一些小技巧/" data-id="cjxbtu1oe001iqo672oa3u5g7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/xiaojn-blog/tags/Algorithm/">Algorithm</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-LeetCode中关于整数处理的几个题目" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/xiaojn-blog/2016/05/02/LeetCode中关于整数处理的几个题目/" class="article-date">
  <time datetime="2016-05-02T07:03:35.000Z" itemprop="datePublished">2016-05-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/xiaojn-blog/categories/算法/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/xiaojn-blog/2016/05/02/LeetCode中关于整数处理的几个题目/">LeetCode中关于整数处理的几个题目</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文主要介绍LeetCode中关于整数的几个算法问题：<br>第7题：<a href="https://leetcode.com/problems/reverse-integer/" target="_blank" rel="noopener">Reverse Integer</a><br>第8题：<a href="https://leetcode.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">String to Integer (atoi)</a><br>第9题：<a href="https://leetcode.com/problems/palindrome-number/" target="_blank" rel="noopener">Palindrome Number</a><br>第13题：<a href="https://leetcode.com/problems/roman-to-integer/" target="_blank" rel="noopener">Roman to Integer</a></p>
<h1 id="Reverse-Integer"><a href="#Reverse-Integer" class="headerlink" title="Reverse Integer"></a>Reverse Integer</h1><p>题目描述：<br>Reverse digits of an integer.<br>Example1: x = 123, return 321<br>Example2: x = -123, return -321</p>
<p>题目的提示：<br>Have you thought about this?<br>Here are some good questions to ask before coding. Bonus points for you if you have already thought through this!
If the integer’s last digit is 0, what should the output be? ie, cases such as 10, 100.<br>Did you notice that the reversed integer might overflow? Assume the input is a 32-bit integer, then the reverse of 1000000003 overflows. How should you handle such cases?<br>For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.<br>方法一思路：只要考虑到溢出的情况存在，这道题目的思路还是相对简单的，按顺序把一个数从个位开始分离，每次循环把低位数升一级，最高位变为最低位。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> max_int = (<span class="number">1</span> &lt;&lt; <span class="number">31</span>) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> min_int = -max_int - <span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">0</span>) &#123;</span><br><span class="line">        n = x % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span>(y &gt; max_int / <span class="number">10</span> || y &lt; min_int / <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        y = y * <span class="number">10</span> + n;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>完整代码地址：<a href="https://github.com/Evanqiao/LeetCode-qyh/blob/master/7_ReverseInteger/ReverseInteger.cpp" target="_blank" rel="noopener">ReverseInteger.cpp</a></p>
<p>方法二思路：把整数转换成字符串，然后再把字符串进行逆转。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3    </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(x)</span>:</span>    </span><br><span class="line">    s = str(x)    </span><br><span class="line">    <span class="keyword">if</span>(x &gt;= <span class="number">0</span>):    </span><br><span class="line">        res = int(str(x)[::<span class="number">-1</span>])    </span><br><span class="line">    <span class="keyword">else</span>:    </span><br><span class="line">        res = -int(str(-x)[::<span class="number">-1</span>])    </span><br><span class="line">    <span class="keyword">if</span> res &gt; <span class="number">2</span> ** <span class="number">31</span> - <span class="number">1</span> <span class="keyword">or</span> res &lt; <span class="number">-2</span> ** <span class="number">31</span>:    </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>    </span><br><span class="line">    <span class="keyword">return</span> res    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:    </span><br><span class="line">    a = reverse(<span class="number">-10324</span>)    </span><br><span class="line">    print(str(a))</span><br></pre></td></tr></table></figure>


<h1 id="String-to-Integer-atoi"><a href="#String-to-Integer-atoi" class="headerlink" title="String to Integer (atoi)"></a>String to Integer (atoi)</h1><p>题目描述：</p>
<p>Implement atoi to convert a string to an integer.<br>Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases.<br>Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front.</p>
<p>需要注意：要考虑边界条件，如输入的字符串为空；输入的字符串带正负号；输入到字符串中包含非数字的字符；转为整数溢出的情况。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (str==<span class="literal">NULL</span> || *str==<span class="string">'\0'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">for</span>(;<span class="built_in">isspace</span>(*str); str++);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">bool</span> neg=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (*str==<span class="string">'-'</span> || *str==<span class="string">'+'</span>) &#123;</span><br><span class="line">        neg = (*str==<span class="string">'-'</span>) ;</span><br><span class="line">        str++;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">for</span>(; <span class="built_in">isdigit</span>(*str); str++) &#123;</span><br><span class="line">        <span class="keyword">int</span> digit = (*str-<span class="string">'0'</span>);</span><br><span class="line">        <span class="keyword">if</span>(neg)&#123;</span><br><span class="line">            <span class="keyword">if</span>( -ret &lt; (INT_MIN + digit)/<span class="number">10</span> ) &#123;</span><br><span class="line">                <span class="keyword">return</span> INT_MIN;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>( ret &gt; (INT_MAX - digit) /<span class="number">10</span> ) &#123;</span><br><span class="line">                <span class="keyword">return</span> INT_MAX;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        ret = <span class="number">10</span>*ret + digit ;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> neg ? -ret : ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整代码：<a href="https://github.com/Evanqiao/LeetCode-qyh/blob/master/8_StringToInteger/StringToInteger.c" target="_blank" rel="noopener">StringToInteger.c</a></p>
<h1 id="Palindrome-Number"><a href="#Palindrome-Number" class="headerlink" title="Palindrome Number"></a>Palindrome Number</h1><p>题目描述：<br>Determine whether an integer is a palindrome. Do this without extra space.<br>思路：注意到负数不是回文数。给一个数32623，首先计算出这个数的长度，即算出它的数量级，最高位是千、万还是十万位，然后逐步分离该数字的最低位和最高位，拿最低位和最高位进行比较，如果不相等就不是回文数，否则即为回文数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> lhs = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rhs = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> temp = x / <span class="number">10</span>; temp != <span class="number">0</span>; temp /= <span class="number">10</span>, len *= <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">while</span>(x) &#123;</span><br><span class="line">        lhs = x / len;</span><br><span class="line">        rhs = x % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span>(lhs != rhs)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        x = (x % len) / <span class="number">10</span>;</span><br><span class="line">        len /= <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>完整代码：<a href="https://github.com/Evanqiao/LeetCode-qyh/blob/master/9_PalindromeNumber/palindromeNumber.cpp" target="_blank" rel="noopener">palindromeNumber.cpp</a></p>
<h1 id="Roman-to-Integer"><a href="#Roman-to-Integer" class="headerlink" title="Roman to Integer"></a>Roman to Integer</h1><p>题目描述：</p>
<p>Given a roman numeral, convert it to an integer.<br>Input is guaranteed to be within the range from 1 to 3999.<br>首先要知道Roman数的计数规则：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/*    </span><br><span class="line">* 简单的罗马数字见下:    </span><br><span class="line">* I - 1     </span><br><span class="line">* II - 2     </span><br><span class="line">* III - 3     </span><br><span class="line">* IV - 4     </span><br><span class="line">* V - 5     </span><br><span class="line">* VI - 6     </span><br><span class="line">* X - 10     </span><br><span class="line">* L - 50     </span><br><span class="line">* C - 100     </span><br><span class="line">* D - 500     </span><br><span class="line">* M - 1000     </span><br><span class="line">* 罗马数字共有七个，即I(1)，V(5)，X(10)，L(50)，C(100)，D(500)，M(1000)。    </span><br><span class="line">* 按照下面的规则可以表示任意正整数。    </span><br><span class="line">*    </span><br><span class="line">* 重复数次：一个罗马数字重复几次，就表示这个数的几倍。     </span><br><span class="line">* 右加左减：在一个较大的罗马数字的右边记上一个较小的罗马数字，表示大数字加小数字。    </span><br><span class="line">* 在一个较大的数字的左边记上一个较小的罗马数字，表示大数字减小数字。    </span><br><span class="line">* 但是，左减不能跨越等级。比如，99不可以用IC表示，用XCIX表示。     </span><br><span class="line">* 加线乘千：在一个罗马数字的上方加上一条横线或者在右下方写M，    </span><br><span class="line">* 表示将这个数字乘以1000，即是原数的1000倍。    </span><br><span class="line">* 同理，如果上方有两条横线，即是原数的1000000倍。     </span><br><span class="line">* 单位限制：同样单位只能出现3次，如40不能表示为XXXX，而要表示为XL。     </span><br><span class="line">*    </span><br><span class="line">* MCXIV----1114    </span><br><span class="line">* CCCLIX---359    </span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>思路：先把每一个罗马数字的字母对应的数表示出来。遵循左减右加原则，从所给罗马字符串的第一个字符起开始处理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>    </span></span><br><span class="line"><span class="class">&#123;</span>    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span>    </span></span><br><span class="line"><span class="function">    </span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> len = s.size();    </span><br><span class="line">    <span class="keyword">if</span>(s.size() &lt;= <span class="number">0</span>)    </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">int</span> res = romanCharToInt(s[<span class="number">0</span>]);    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;    </span><br><span class="line">        <span class="keyword">int</span> prev = romanCharToInt(s[i<span class="number">-1</span>]);    </span><br><span class="line">        <span class="keyword">int</span> curr = romanCharToInt(s[i]);    </span><br><span class="line">        <span class="keyword">if</span>(prev &lt; curr) &#123;    </span><br><span class="line">            res = res - prev + (curr - prev);       </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    </span><br><span class="line">            res += curr;      </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> res;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanCharToInt</span><span class="params">(<span class="keyword">char</span> ch)</span>    </span></span><br><span class="line"><span class="function">    </span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">0</span>;     </span><br><span class="line">    <span class="keyword">switch</span>(ch) &#123;    </span><br><span class="line">    <span class="keyword">case</span> <span class="string">'I'</span>:    </span><br><span class="line">        val = <span class="number">1</span>;    </span><br><span class="line">        <span class="keyword">break</span>;    </span><br><span class="line">    <span class="keyword">case</span> <span class="string">'V'</span>:    </span><br><span class="line">        val = <span class="number">5</span>;    </span><br><span class="line">        <span class="keyword">break</span>;    </span><br><span class="line">    <span class="keyword">case</span> <span class="string">'X'</span>:    </span><br><span class="line">        val = <span class="number">10</span>;    </span><br><span class="line">        <span class="keyword">break</span>;    </span><br><span class="line">    <span class="keyword">case</span> <span class="string">'L'</span>:    </span><br><span class="line">        val = <span class="number">50</span>;    </span><br><span class="line">        <span class="keyword">break</span>;    </span><br><span class="line">    <span class="keyword">case</span> <span class="string">'C'</span>:    </span><br><span class="line">        val = <span class="number">100</span>;    </span><br><span class="line">        <span class="keyword">break</span>;    </span><br><span class="line">    <span class="keyword">case</span> <span class="string">'D'</span>:    </span><br><span class="line">        val = <span class="number">500</span>;    </span><br><span class="line">        <span class="keyword">break</span>;    </span><br><span class="line">        <span class="keyword">case</span> <span class="string">'M'</span>:    </span><br><span class="line">        val = <span class="number">1000</span>;    </span><br><span class="line">        <span class="keyword">break</span>;    </span><br><span class="line">    <span class="keyword">default</span>:    </span><br><span class="line">        <span class="keyword">break</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> val;        </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>完整代码：<a href="https://github.com/Evanqiao/LeetCode-qyh/blob/master/13_RomanToInteger/RomanToInteger.cpp" target="_blank" rel="noopener">RomanToInteger.cpp</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://evanqiao.github.io/xiaojn-blog/2016/05/02/LeetCode中关于整数处理的几个题目/" data-id="cjxbtu1nf000aqo6725xfe5jr" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/xiaojn-blog/tags/Algorithm/">Algorithm</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/xiaojn-blog/page/2/">&laquo; __('prev')</a><a class="page-number" href="/xiaojn-blog/">1</a><a class="page-number" href="/xiaojn-blog/page/2/">2</a><span class="page-number current">3</span>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/xiaojn-blog/categories/Tools/">Tools</a></li><li class="category-list-item"><a class="category-list-link" href="/xiaojn-blog/categories/博客建设/">博客建设</a></li><li class="category-list-item"><a class="category-list-link" href="/xiaojn-blog/categories/我学编程/">我学编程</a></li><li class="category-list-item"><a class="category-list-link" href="/xiaojn-blog/categories/文清说/">文清说</a></li><li class="category-list-item"><a class="category-list-link" href="/xiaojn-blog/categories/算法/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/xiaojn-blog/categories/编程语言/">编程语言</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/xiaojn-blog/tags/Algorithm/">Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/xiaojn-blog/tags/C/">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/xiaojn-blog/tags/MarkDown/">MarkDown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/xiaojn-blog/tags/Mathematics/">Mathematics</a></li><li class="tag-list-item"><a class="tag-list-link" href="/xiaojn-blog/tags/May/">May</a></li><li class="tag-list-item"><a class="tag-list-link" href="/xiaojn-blog/tags/Raspberry/">Raspberry</a></li><li class="tag-list-item"><a class="tag-list-link" href="/xiaojn-blog/tags/free/">free</a></li><li class="tag-list-item"><a class="tag-list-link" href="/xiaojn-blog/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/xiaojn-blog/tags/vim/">vim</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/xiaojn-blog/tags/Algorithm/" style="font-size: 20px;">Algorithm</a> <a href="/xiaojn-blog/tags/C/" style="font-size: 13.33px;">C++</a> <a href="/xiaojn-blog/tags/MarkDown/" style="font-size: 10px;">MarkDown</a> <a href="/xiaojn-blog/tags/Mathematics/" style="font-size: 13.33px;">Mathematics</a> <a href="/xiaojn-blog/tags/May/" style="font-size: 10px;">May</a> <a href="/xiaojn-blog/tags/Raspberry/" style="font-size: 16.67px;">Raspberry</a> <a href="/xiaojn-blog/tags/free/" style="font-size: 10px;">free</a> <a href="/xiaojn-blog/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/xiaojn-blog/tags/vim/" style="font-size: 10px;">vim</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/xiaojn-blog/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/xiaojn-blog/archives/2017/06/">六月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/xiaojn-blog/archives/2017/05/">五月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/xiaojn-blog/archives/2017/04/">四月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/xiaojn-blog/archives/2017/03/">三月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/xiaojn-blog/archives/2016/08/">八月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/xiaojn-blog/archives/2016/07/">七月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/xiaojn-blog/archives/2016/05/">五月 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/xiaojn-blog/2017/07/30/NOIP2013_2表达式求值/">NOIP2013表达式求值</a>
          </li>
        
          <li>
            <a href="/xiaojn-blog/2017/07/30/NOIP2012_02寻宝/">NOIP2012寻宝</a>
          </li>
        
          <li>
            <a href="/xiaojn-blog/2017/06/05/斜挎包的聚会/">跨斜包的聚会</a>
          </li>
        
          <li>
            <a href="/xiaojn-blog/2017/06/04/Practical_backTracking/">实践回溯法</a>
          </li>
        
          <li>
            <a href="/xiaojn-blog/2017/05/21/heap_priority_queue/">堆和优先队列的算法应用</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 qiaoyihan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/xiaojn-blog/" class="mobile-nav-link">Home</a>
  
    <a href="/xiaojn-blog/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/xiaojn-blog/fancybox/jquery.fancybox.css">
  <script src="/xiaojn-blog/fancybox/jquery.fancybox.pack.js"></script>


<script src="/xiaojn-blog/js/script.js"></script>

  </div><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>
</html>