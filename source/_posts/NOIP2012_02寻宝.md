title: NOIP2012寻宝
date: 2017-7-30 13:17:45
categories: 我学编程
tags: 
 - Algorithm
toc: true
comments: true
---

## 题目描述

【题目描述】
传说很遥远的藏宝楼顶层藏着诱人的宝藏。小明历尽千辛万苦终于找到传说中的这个藏宝楼，藏宝楼的门口竖着一个木板，上面写有几个大字：寻宝说明书。说明书的内容如下： 藏宝楼共有N+1层，最上面一层是顶层，顶层有一个房间里面藏着宝藏。除了顶层外，藏宝楼另有 N 层，每层 M 个房间，这M个房间围成一圈并按逆时针方向依次编号为0，…，M-1。其中一些房间有通往上一层的楼梯，每层楼的楼梯设计可能不同。每个房间里有一个指示牌，指示牌上有一个数字x，表示从这个房间开始按逆时针方向选择第x个有楼梯的房间（假定该房间的编号为k），从该房间上楼，上楼后到达上一层的k号房间。比如当前房间的指示牌上写着2，则按逆时针方向开始尝试，找到第2个有楼梯的房间，从该房间上楼。如果当前房间本身就有楼梯通向上层，该房间作为第一个有楼梯的房间。
    寻宝说明书的最后用红色大号字体写着：“寻宝须知：帮助你找到每层上楼房间的指示牌上的数字（即每层第一个进入的房间内指示牌上的数字）总和为打开宝箱的密钥”。
请帮助小明算出这个打开宝箱的密钥。

【输入格式】
第一行2个整数N和M，之间用一个空格隔开。N表示除了顶层外藏宝楼共N层楼，M表示除顶层外每层楼有M个房间。
    接下来 N*M 行，每行两个整数，之间用一个空格隔开，每行描述一个房间内的情况，其中第(i-1)*M+j 行表示第i 层j-1号房间的情况（i=1, 2, …, N；j=1, 2, … ,M）。第一个整数表示该房间是否有楼梯通往上一层（0表示没有，1表示有），第二个整数表示指示牌上的数字。注意，从j号房间的楼梯爬到上一层到达的房间一定也是j号房间。
最后一行，一个整数，表示小明从藏宝楼底层的几号房间进入开始寻宝（注：房间编号从0开始）。

【输出格式】
输出只有一行，一个整数，表示打开宝箱的密钥，这个数可能会很大，请输出对20123取模的结果即可。

【输入输出样例】
treasures.in	
2 3
1 2
0 3
1 4
0 1
1 5
1 2
1
treasures.out
5
【输入输出样例说明】
第一层：
 0号房间，有楼梯通往上层，指示牌上的数字是2；
 1号房间，无楼梯通往上层，指示牌上的数字是3；
 2号房间，有楼梯通往上层，指示牌上的数字是4；
第二层：
 0号房间，无楼梯通往上层，指示牌上的数字是1；
 1号房间，有楼梯通往上层，指示牌上的数字是5；
 2号房间，有楼梯通往上层，指示牌上的数字是2；
小明首先进入第一层（底层）的1号房间，记下指示牌上的数字为3，然后从这个房间开始，沿逆时针方向选择第3个有楼梯的房间2号房间进入，上楼后到达第二层的2号房间，记下指示牌上的数字为2，由于当前房间本身有楼梯通向上层，该房间作为第一个有楼梯的房间。因此，此时沿逆时针方向选择第2个有楼梯的房间即为1号房间，进入后上楼梯到达顶层。这时把上述记下的指示牌上的数字加起来，即3+2=5，所以打开宝箱的密钥就是5。

【数据规模】
对于50%数据，有0<N≤1000，0<x≤10000；
对于100%数据，有0<N≤10000，0<M≤100，0<x≤1,000,000。

## 思路
模拟寻找宝藏的过程，从底层开始，依次上楼，在这个过程中保存在每一层的第一个进去的房间里指示牌上的数字，并加到sum变量上，同时根据指示牌上的数字（flagNo），逆序寻找下一层的房间号，这里寻找房间比较费时间，如果指示牌上的数字远远大于每层有电梯的房间数，则要循环很多次才能找到逆序的第flagNo个有电梯的房间，所以这里的做法是在输入的时候，统计每层有电梯的房间总数，存放在一维数组中。寻找房间用下面几行代码就可以在一次循环内找到下一层对应的房间。算法的时间复杂度是O(n*m)。

## 代码
```C++
//
// Created by qyh-mac on 2017/7/29.
//
#include <iostream>
#include <vector>
#include <cstdio>
using namespace std;

typedef struct {
    bool hasStair;
    int number;
} Room;

int main() {
    freopen("treasures.in", "r", stdin);
    freopen("treasures.out", "w", stdout);
    int n, m;
    cin >> n >> m;
    vector<vector<Room> > table(n, vector<Room>(m));
    vector<int> roomsHasStairPerFloor(n);
    for(int i = 0; i < n; i++) {
        int temp = 0;
        for(int j = 0; j < m; j++) {
            cin >> table[i][j].hasStair >> table[i][j].number;
            if(table[i][j].hasStair)
                ++temp;
        }
        // 记录每层一共有多少个房间有电梯
        roomsHasStairPerFloor[i] = temp;
    }
    int roomNo;
    cin >> roomNo;
    int sum = 0;
    for(int i = 0; i < n; i++) {
        int flagNo = table[i][roomNo].number;
        sum += flagNo;
        int count = 0;
        int j = roomNo;
        // 简化找房间的过程。防止因指示牌上的数字过大而导致循环次数增多
        int temp = (flagNo + roomsHasStairPerFloor[i]) % roomsHasStairPerFloor[i];
        if(temp == 0)
            temp = roomsHasStairPerFloor[i];
        while(count < temp) {
            if(table[i][(j + m) % m].hasStair)
                count++;
            j++;
        }
        roomNo = (j + m - 1) % m;
    }
    cout << sum % 20123 << endl;
    return 0;
}
```
