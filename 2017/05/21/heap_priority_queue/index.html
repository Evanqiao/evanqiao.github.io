<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="blog.xiaojn.cn"><title>堆和优先队列的算法应用 | 晓江南的博客</title><link rel="stylesheet" type="text/css" href="/evanqiao.github.io/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/evanqiao.github.io/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/evanqiao.github.io/favicon.ico"><link rel="apple-touch-icon" href="/evanqiao.github.io/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/evanqiao.github.io/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">堆和优先队列的算法应用</h1><a id="logo" href="/evanqiao.github.io/.">晓江南的博客</a><p class="description">Hope is a good thing!</p></div><div id="nav-menu"><a class="current" href="/evanqiao.github.io/."><i class="fa fa-home"> 首页</i></a><a href="/evanqiao.github.io/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/evanqiao.github.io/about/"><i class="fa fa-user"> 关于</i></a><a href="/evanqiao.github.io/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">堆和优先队列的算法应用</h1><div class="post-meta">May 21, 2017<span> | </span><span class="category"><a href="/evanqiao.github.io/categories/我学编程/">我学编程</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#银行排队问题"><span class="toc-number">1.</span> <span class="toc-text">银行排队问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#性能一般的方法"><span class="toc-number">1.1.</span> <span class="toc-text">性能一般的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#性能更好的方法"><span class="toc-number">1.2.</span> <span class="toc-text">性能更好的方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#堆排序的原理与特性"><span class="toc-number">2.</span> <span class="toc-text">堆排序的原理与特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#堆排序实现"><span class="toc-number">3.</span> <span class="toc-text">堆排序实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#方法一"><span class="toc-number">3.1.</span> <span class="toc-text">方法一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法二"><span class="toc-number">3.2.</span> <span class="toc-text">方法二</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法三"><span class="toc-number">3.3.</span> <span class="toc-text">方法三</span></a></li></ol></li></ol></div></div><div class="post-content"><h2 id="银行排队问题"><a href="#银行排队问题" class="headerlink" title="银行排队问题"></a>银行排队问题</h2><p>有n个人去银行排队办事（n&lt;=1000000）。银行只有一个窗口，每人有不同的优先级。每办完一个人，从等待的人中选优先级最高的人办理，同级选最先到的。<br>输入n以及n行数据Ai，Pi，Ti，表示第i个人的到达时间、优先级、办理用时。所有输入都是正整数，输入顺序为Ai递增顺序，输出实际办理的人的顺序。<br>样例输入：<br>5
0 1 10<br>2 1 10<br>5 3 10<br>7 2 5<br>11 3 5<br>样例输出：<br>1 3 5 4 2</p>
<h3 id="性能一般的方法"><a href="#性能一般的方法" class="headerlink" title="性能一般的方法"></a>性能一般的方法</h3><p>建立一个优先队列，优先队列的优先原则是优先级大的在前，如果优先级相同，则达到时间小的在前，如果到达时间相同，则用时短的在前。设一个变量<code>currentTime</code>用来记录当前的时间，根据当前时间来提取队列中的元素，如果队顶元素不满足要求，先出队，按出队顺序保存在数组中，直到遇到符合条件的元素，就让符合条件的元素去办理业务，完后把数组中保存的元素再入队，循环。。。直到队列为空，即所有人都去办理了业务为止。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Member</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> arrTime;</span><br><span class="line">    <span class="keyword">int</span> priority;</span><br><span class="line">    <span class="keyword">int</span> conTime;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consructMember</span><span class="params">(Member &amp;m, <span class="keyword">int</span> arrTime, <span class="keyword">int</span> priority, <span class="keyword">int</span> conTime, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    m.arrTime = arrTime;</span><br><span class="line">    m.priority = priority;</span><br><span class="line">    m.conTime = conTime;</span><br><span class="line">    m.id = id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Member &amp;m1, <span class="keyword">const</span> Member &amp;m2) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(m1.priority != m2.priority) &#123;</span><br><span class="line">        <span class="keyword">return</span> m1.priority &lt; m2.priority;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(m1.arrTime != m2.arrTime) &#123;</span><br><span class="line">        <span class="keyword">return</span>  m1.arrTime &gt; m2.arrTime;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>  m1.conTime &gt; m2.conTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bankQueue(priority_queue&lt;Member&gt; &amp;pq_m, <span class="keyword">int</span> currentTime) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Member&gt; vec_m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!pq_m.empty()) &#123;</span><br><span class="line">        Member m = pq_m.top();</span><br><span class="line">        <span class="keyword">while</span>(m.arrTime &gt; currentTime) &#123;</span><br><span class="line">            vec_m.push_back(m);</span><br><span class="line">            pq_m.pop();</span><br><span class="line">            m = pq_m.top();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(m.arrTime &lt;= currentTime) &#123;</span><br><span class="line">            pq_m.pop();</span><br><span class="line">            result.push_back(m.id);</span><br><span class="line">            currentTime += m.conTime;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec_m.size(); i++) &#123;</span><br><span class="line">            pq_m.push(vec_m[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        vec_m.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">0 1 10</span></span><br><span class="line"><span class="comment">2 1 10</span></span><br><span class="line"><span class="comment">5 3 10</span></span><br><span class="line"><span class="comment">7 2 5</span></span><br><span class="line"><span class="comment">11 3 5</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    Member member[n];</span><br><span class="line">    <span class="keyword">int</span> a, p, c;</span><br><span class="line">    priority_queue&lt;Member&gt; pq_m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">int</span> currentTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; p &gt;&gt; c;</span><br><span class="line">        consructMember(member[i], a, p, c, i + <span class="number">1</span>);</span><br><span class="line">        pq_m.push(member[i]);</span><br><span class="line">        currentTime = i == <span class="number">0</span> ? a : currentTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result = bankQueue(pq_m, currentTime);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i : result)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>辅导班老师指出这个代码存在的问题：<br>这个算法逻辑上还有一些小bug。<br>首先bankQueue函数里少了一些判断，导致有些输入的时候会死循环<br>另外你这个算法对某些人做了反复出堆和入堆，在某些极端情况下复杂度会到达O(n^2*logn)<br>下面这组数据就会同时触发上面这两件事情<br>    10<br>    0 1 1<br>    2 2 1<br>    4 3 1<br>    6 4 1<br>    8 5 1<br>    10 6 1<br>    12 7 1<br>    14 8 1<br>    16 9 1<br>    18 10 1</p>
<p><strong>修复bug后的代码：</strong> <a href="https://github.com/Evanqiao/CSTutorship/blob/master/Algorithm/bankQueue/bankqueue2.cpp" target="_blank" rel="noopener">bankqueue2.cpp</a></p>
<h3 id="性能更好的方法"><a href="#性能更好的方法" class="headerlink" title="性能更好的方法"></a>性能更好的方法</h3><p>思路：<br>维护两个数据结构，一个是<code>vector</code>，按先来后到的顺序存放每个<code>member</code>，一个是优先队列<code>priority_queue</code>，优先队列的优先原则是优先级大的在前，如果优先级相同，则达到时间小的在前，如果到达时间相同，则用时短的在前。设一个变量<code>currentTime</code>用来记录当前的时间。<br>首先，去访问队列中的成员，如果该成员已经服务过，直接删除，如果没有，则判断该成员是否已经到来，如果到来则访问，并记录他的编号，然后删除。如果队列头元素没有到来，就去<code>vector</code>数组中访问当前游标指向的成员，访问后游标加1，并置访问过的成员的标志为<code>true</code>。
要注意的是:</p>
<ol>
<li>两个数据结构里面存放的都是指针;</li>
<li>相比方法一，<code>Member</code>中添加了一个成员变量<code>isVisited</code>，用来标记当前成员是否已经服务过了。</li>
<li>循环的退出条件是队列为空或者数组已遍历一遍。</li>
</ol>
<p>该算法的时间复杂度相比方法一提高了不少，为<code>O(nlogn)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Member</span> &#123;</span></span><br><span class="line">	<span class="comment">// 依次对应每个成员的到达时间、优先级、消耗时间、编号、是否已经服务过</span></span><br><span class="line">	<span class="keyword">int</span> arrTime;</span><br><span class="line">	<span class="keyword">int</span> priority;</span><br><span class="line">	<span class="keyword">int</span> conTime;</span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">bool</span> isVisited;</span><br><span class="line">	<span class="comment">// 构造函数</span></span><br><span class="line">	Member(<span class="keyword">int</span> arrT, <span class="keyword">int</span> p, <span class="keyword">int</span> conT, <span class="keyword">int</span> i, <span class="keyword">bool</span> f) :</span><br><span class="line">		arrTime(arrT), priority(p), conTime(conT), id(i), isVisited(f) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义自己的比较函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mycmp</span> &#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(<span class="keyword">const</span> Member* m1, <span class="keyword">const</span> Member* m2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(m1-&gt;priority != m2-&gt;priority) &#123;</span><br><span class="line">			<span class="keyword">return</span> m1-&gt;priority &lt; m2-&gt;priority;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span>(m1-&gt;arrTime != m2-&gt;arrTime) &#123;</span><br><span class="line">			<span class="keyword">return</span>  m1-&gt;arrTime &gt; m2-&gt;arrTime;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span>  m1-&gt;conTime &gt; m2-&gt;conTime;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bankQueue(priority_queue&lt;Member*, <span class="built_in">vector</span>&lt;Member*&gt;, mycmp&gt; &amp;pq_m, Member *pmem[], <span class="keyword">int</span> n) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	<span class="keyword">int</span> currentTime = pmem[<span class="number">0</span>]-&gt;arrTime;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(i &lt; n &amp;&amp; pq_m.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		Member *m = pq_m.top();</span><br><span class="line">		<span class="keyword">if</span>(m-&gt;isVisited) &#123;</span><br><span class="line">			pq_m.pop();</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(m-&gt;arrTime &lt;= currentTime) &#123;</span><br><span class="line">			m-&gt;isVisited = <span class="literal">true</span>;</span><br><span class="line">			result.push_back(m-&gt;id);</span><br><span class="line">			currentTime += m-&gt;conTime;</span><br><span class="line">			pq_m.pop();</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(pmem[i]-&gt;isVisited == <span class="literal">false</span>) &#123;</span><br><span class="line">				result.push_back(pmem[i]-&gt;id);</span><br><span class="line">				pmem[i]-&gt;isVisited = <span class="literal">true</span>;</span><br><span class="line">				currentTime += pmem[i]-&gt;conTime;</span><br><span class="line">			&#125;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   5</span></span><br><span class="line"><span class="comment">   0 1 10</span></span><br><span class="line"><span class="comment">   2 1 10</span></span><br><span class="line"><span class="comment">   5 3 10</span></span><br><span class="line"><span class="comment">   7 2 5</span></span><br><span class="line"><span class="comment">   11 3 5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	Member *pmember[n];</span><br><span class="line">	<span class="keyword">int</span> a, p, c;</span><br><span class="line">	<span class="comment">// 定义优先队列</span></span><br><span class="line">	priority_queue&lt;Member*, <span class="built_in">vector</span>&lt;Member*&gt;, mycmp&gt; pq_m;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; p &gt;&gt; c;</span><br><span class="line">		pmember[i] = <span class="keyword">new</span> Member(a, p, c, i + <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">		pq_m.push(pmember[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	result = bankQueue(pq_m, pmember, n);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i : result)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="堆排序的原理与特性"><a href="#堆排序的原理与特性" class="headerlink" title="堆排序的原理与特性"></a>堆排序的原理与特性</h2><p>这部分我之前总结过。详见<a href="http://blog.xiaojn.cn/2016/08/25/%E5%85%B8%E5%9E%8B%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%9B%9E%E9%A1%BE/#7-堆排序" target="_blank" rel="noopener">典型排序算法 - 堆排序</a><br>堆排序动态示例：<br><img src="https://upload.wikimedia.org/wikipedia/commons/4/4d/Heapsort-example.gif" alt="堆排序升序排列"></p>
<h2 id="堆排序实现"><a href="#堆排序实现" class="headerlink" title="堆排序实现"></a>堆排序实现</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><ol>
<li>在原数组上建立最小堆；</li>
<li>交换数组的第一个元素和最后一个元素；</li>
<li>维护最小堆；</li>
<li>重复2-3步骤直到完成数组中所有元素的排序。  </li>
</ol>
<p>此方法的时间复杂度为O(nlogn)，空间复杂度为O(1)。<br><strong>提示：</strong>建堆的方法和过程参考上面给出的堆排序的链接。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        buildMinHeap(A, n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="built_in">std</span>::swap(A[<span class="number">0</span>], A[i]);</span><br><span class="line">            heap_size--;</span><br><span class="line">            minHeapify(A, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">minHeapify</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> left = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">int</span> right = <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line">    	<span class="keyword">int</span> lowest = <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">if</span>(left &lt; heap_size &amp;&amp; A[left] &lt; A[index]) &#123;</span><br><span class="line">            lowest = left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lowest = index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right &lt; heap_size &amp;&amp; A[right] &lt; A[lowest])</span><br><span class="line">            lowest = right;</span><br><span class="line">        <span class="keyword">if</span>(lowest != index) &#123;</span><br><span class="line">        	<span class="built_in">std</span>::swap(A[index], A[lowest]);</span><br><span class="line">        	minHeapify(A, lowest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildMinHeap</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    	heap_size = n;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = (n - <span class="number">2</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            minHeapify(A, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> heap_size = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[] = &#123;<span class="number">9</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">19</span>, <span class="number">8</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    HeapSort h;</span><br><span class="line">    h.heapSort(A, n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> e : A) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="string">"  "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><ol>
<li>在原数组上建立最大堆；</li>
<li>把数组的第一个元素放入新的数组中，把数组最后一个元素赋值给第一个元素；</li>
<li>维护最大堆；</li>
<li>重复2-3步骤直到完成数组中所有元素的排序。  </li>
</ol>
<p>此方法的时间复杂度为O(nlogn)，空间复杂度为O(n)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        buildMaxHeap(A, n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            B.push_back(A[<span class="number">0</span>]);</span><br><span class="line">            A[<span class="number">0</span>] = A[i];</span><br><span class="line">            heap_size--;</span><br><span class="line">            maxHeapify(A, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">maxHeapify</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> left = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">int</span> right = <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line">    	<span class="keyword">int</span> largest = <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">if</span>(left &lt; heap_size &amp;&amp; A[left] &gt; A[index]) &#123;</span><br><span class="line">            largest = left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            largest = index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right &lt; heap_size &amp;&amp; A[right] &gt; A[largest])</span><br><span class="line">            largest = right;</span><br><span class="line">        <span class="keyword">if</span>(largest != index) &#123;</span><br><span class="line">        	<span class="built_in">std</span>::swap(A[index], A[largest]);</span><br><span class="line">        	maxHeapify(A, largest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    	heap_size = n;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = (n - <span class="number">2</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            maxHeapify(A, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> heap_size = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[] = &#123;<span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">19</span>, <span class="number">8</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; B;</span><br><span class="line">    HeapSort h;</span><br><span class="line">    h.heapSort(A, B, n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> e : B) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="string">"  "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><p>按照课堂上老师的代码进行修改，先建立一个最大堆，然后依次打印出堆顶元素。</p>
<p><strong>提示：</strong>这里的代码不一定是最好的，也不一定非要建立一个最大堆。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxHeap</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:  <span class="comment">// private表示只有在class内部可访问</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data;   <span class="comment">// 数据，因为是满二叉树，用数组存就可以</span></span><br><span class="line">    <span class="keyword">int</span> capacity,size;  <span class="comment">// 最大容量，实际数量</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a,<span class="keyword">int</span> &amp;b)</span></span>&#123;   <span class="comment">// 交换整数辅助函数</span></span><br><span class="line">        a=a+b;</span><br><span class="line">        b=a-b;</span><br><span class="line">        a=a-b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从节点i开始恢复堆的特性</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recover</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&gt;<span class="number">1</span> &amp;&amp; data[i/<span class="number">2</span>]&lt;data[i])&#123;</span><br><span class="line">            swap(data[i/<span class="number">2</span>],data[i]);</span><br><span class="line">            recover(i/<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i*<span class="number">2</span>+<span class="number">1</span>&lt;=size &amp;&amp; data[i*<span class="number">2</span>+<span class="number">1</span>]&gt;data[i] &amp;&amp; data[i*<span class="number">2</span>+<span class="number">1</span>]&gt;=data[i*<span class="number">2</span>])&#123; <span class="comment">// 右子树最大</span></span><br><span class="line">            swap(data[i*<span class="number">2</span>+<span class="number">1</span>],data[i]);</span><br><span class="line">            recover(i*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i*<span class="number">2</span>&lt;=size &amp;&amp; data[i*<span class="number">2</span>]&gt;data[i] &amp;&amp; (i*<span class="number">2</span>+<span class="number">1</span>&gt;size || data[i*<span class="number">2</span>]&gt;data[i*<span class="number">2</span>+<span class="number">1</span>]))&#123; <span class="comment">// 左子树最大</span></span><br><span class="line">            swap(data[i*<span class="number">2</span>],data[i]);</span><br><span class="line">            recover(i*<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    MaxHeap(<span class="keyword">const</span> <span class="keyword">int</span>&amp; n)&#123; <span class="comment">// 初始化</span></span><br><span class="line">        data.empty();</span><br><span class="line">        capacity=<span class="number">1</span>&lt;&lt;n;</span><br><span class="line">        size=<span class="number">0</span>;</span><br><span class="line">        data.reserve(capacity);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeRoot</span><span class="params">()</span> </span>&#123;  <span class="comment">// 删除根节点并返回其值</span></span><br><span class="line">        <span class="keyword">int</span> root= data[<span class="number">1</span>];</span><br><span class="line">        data[<span class="number">1</span>]=data[size--];</span><br><span class="line">        recover(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123; <span class="comment">// 新增一个元素</span></span><br><span class="line">        data[++size]=value;</span><br><span class="line">        recover(size);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;   <span class="comment">// 用友好的方式输出堆的内容</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=size;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> left=i*<span class="number">2</span>&lt;=size?data[i*<span class="number">2</span>]:<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">int</span> right=i*<span class="number">2</span>+<span class="number">1</span>&lt;=size?data[i*<span class="number">2</span>+<span class="number">1</span>]:<span class="number">-1</span>;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;data[i]&lt;&lt;<span class="string">"("</span>&lt;&lt;left&lt;&lt;<span class="string">","</span>&lt;&lt;right&lt;&lt;<span class="string">")"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> data[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> level=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n; i&gt;<span class="number">0</span>; i&gt;&gt;=<span class="number">1</span>,level++); <span class="comment">// 计算能容纳n个节点的堆的高度</span></span><br><span class="line">    <span class="function">MaxHeap <span class="title">heap</span><span class="params">(level)</span></span>;    <span class="comment">// 初始化堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;  <span class="comment">// 入堆</span></span><br><span class="line">        heap.insert(data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> max = heap.removeRoot(); <span class="comment">// 取出堆顶元素，即最大的元素</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; max &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/*9</span></span><br><span class="line"><span class="comment">     4 3 5 7 11 90 7 29 3*/</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">int</span> data[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;data[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    heapSort(data, n);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div><div class="tags"><a href="/evanqiao.github.io/tags/Algorithm/">Algorithm</a></div><div class="post-nav"><a class="pre" href="/evanqiao.github.io/2017/06/04/Practical_backTracking/">实践回溯法</a><a class="next" href="/evanqiao.github.io/2017/05/14/The_first_one/">The First One</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://evanqiao.github.io/evanqiao.github.io"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/evanqiao.github.io/categories/Tools/">Tools</a></li><li class="category-list-item"><a class="category-list-link" href="/evanqiao.github.io/categories/博客建设/">博客建设</a></li><li class="category-list-item"><a class="category-list-link" href="/evanqiao.github.io/categories/我学编程/">我学编程</a></li><li class="category-list-item"><a class="category-list-link" href="/evanqiao.github.io/categories/文清说/">文清说</a></li><li class="category-list-item"><a class="category-list-link" href="/evanqiao.github.io/categories/算法/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/evanqiao.github.io/categories/编程语言/">编程语言</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/evanqiao.github.io/tags/C/" style="font-size: 15px;">C++</a> <a href="/evanqiao.github.io/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/evanqiao.github.io/tags/Raspberry/" style="font-size: 15px;">Raspberry</a> <a href="/evanqiao.github.io/tags/Algorithm/" style="font-size: 15px;">Algorithm</a> <a href="/evanqiao.github.io/tags/MarkDown/" style="font-size: 15px;">MarkDown</a> <a href="/evanqiao.github.io/tags/Mathematics/" style="font-size: 15px;">Mathematics</a> <a href="/evanqiao.github.io/tags/vim/" style="font-size: 15px;">vim</a> <a href="/evanqiao.github.io/tags/May/" style="font-size: 15px;">May</a> <a href="/evanqiao.github.io/tags/free/" style="font-size: 15px;">free</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/evanqiao.github.io/2017/07/30/NOIP2012_02寻宝/">NOIP2012寻宝</a></li><li class="post-list-item"><a class="post-list-link" href="/evanqiao.github.io/2017/07/30/NOIP2013_2表达式求值/">NOIP2013表达式求值</a></li><li class="post-list-item"><a class="post-list-link" href="/evanqiao.github.io/2017/06/05/斜挎包的聚会/">跨斜包的聚会</a></li><li class="post-list-item"><a class="post-list-link" href="/evanqiao.github.io/2017/06/04/Practical_backTracking/">实践回溯法</a></li><li class="post-list-item"><a class="post-list-link" href="/evanqiao.github.io/2017/05/21/heap_priority_queue/">堆和优先队列的算法应用</a></li><li class="post-list-item"><a class="post-list-link" href="/evanqiao.github.io/2017/05/14/The_first_one/">The First One</a></li><li class="post-list-item"><a class="post-list-link" href="/evanqiao.github.io/2017/05/14/来玩一下超声波测距/">来玩一下超声波测距</a></li><li class="post-list-item"><a class="post-list-link" href="/evanqiao.github.io/2017/05/14/Practical_binaryTree/">初探二叉树的应用</a></li><li class="post-list-item"><a class="post-list-link" href="/evanqiao.github.io/2017/05/09/cpp_exercises_1/">C++练习题目（一）</a></li><li class="post-list-item"><a class="post-list-link" href="/evanqiao.github.io/2017/05/08/LCD通过按键控制显示自定义图标/">LCD通过按键显示自定义图标</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/evanqiao.github.io/." rel="nofollow">晓江南的博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/evanqiao.github.io/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/evanqiao.github.io/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/evanqiao.github.io/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/evanqiao.github.io/js/smartresize.js?v=0.0.0"></script></div></body></html>