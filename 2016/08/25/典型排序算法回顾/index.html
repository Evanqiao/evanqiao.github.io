<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="blog.xiaojn.cn"><title>典型排序算法回顾 | 晓江南的博客</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">典型排序算法回顾</h1><a id="logo" href="/.">晓江南的博客</a><p class="description">Hope is a good thing!</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/guestbook/"><i class="fa fa-comments"> 留言</i></a><a href="/learnProgramming/"><i class="fa fa-code"> 我学编程</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">典型排序算法回顾</h1><div class="post-meta">Aug 25, 2016<span> | </span><span class="category"><a href="/categories/算法/">算法</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 10k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 56</span><span class="post-meta-item-text"> 分钟</span></span></span></div><a class="disqus-comment-count" data-disqus-identifier="2016/08/25/典型排序算法回顾/" href="/2016/08/25/典型排序算法回顾/#disqus_thread"></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-排序算法的分类"><span class="toc-number">1.</span> <span class="toc-text">1. 排序算法的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-稳定性"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 稳定性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-排序算法的比较"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 排序算法的比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-基于插入的排序算法"><span class="toc-number">2.</span> <span class="toc-text">2. 基于插入的排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-直接插入排序"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 直接插入排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对链表的直接插入排序"><span class="toc-number">2.2.</span> <span class="toc-text">对链表的直接插入排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-希尔排序"><span class="toc-number">2.3.</span> <span class="toc-text">2.2 希尔排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#伪代码"><span class="toc-number">2.3.1.</span> <span class="toc-text">伪代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#希尔排序的C-代码实现"><span class="toc-number">2.3.2.</span> <span class="toc-text">希尔排序的C++代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ShellSort-Analysis"><span class="toc-number">2.3.3.</span> <span class="toc-text">ShellSort Analysis</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Stability"><span class="toc-number">2.3.3.1.</span> <span class="toc-text">Stability</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Shellsort-has-O-n-log-n-best-case-time"><span class="toc-number">2.3.3.2.</span> <span class="toc-text">Shellsort has O(n*log(n)) best case time</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Shellsort-worst-case-time-is-no-worse-than-quadratic"><span class="toc-number">2.3.3.3.</span> <span class="toc-text">Shellsort worst case time is no worse than quadratic</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Shellsort-worst-and-average-times"><span class="toc-number">2.3.3.4.</span> <span class="toc-text">Shellsort worst and average times</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-冒泡排序"><span class="toc-number">3.</span> <span class="toc-text">3. 冒泡排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#冒泡排序算法复杂度分析"><span class="toc-number">3.0.1.</span> <span class="toc-text">冒泡排序算法复杂度分析</span></a></li></ol></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#4-快速排序"><span class="toc-number">4.</span> <span class="toc-text">4. 快速排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-快速排序的几种算法描述"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 快速排序的几种算法描述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1-快速排序的描述和Java代码实现-Open-Data-Structures-in-Java"><span class="toc-number">4.1.1.</span> <span class="toc-text">4.1.1 快速排序的描述和Java代码实现(Open Data Structures(in Java))</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2-算法导论一书中第7章快速排序的描述"><span class="toc-number">4.1.2.</span> <span class="toc-text">4.1.2 算法导论一书中第7章快速排序的描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-3-Hoare-partition-scheme"><span class="toc-number">4.1.3.</span> <span class="toc-text">4.1.3 Hoare partition scheme</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-快速排序的算法复杂度分析"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 快速排序的算法复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-归并排序"><span class="toc-number">5.</span> <span class="toc-text">5. 归并排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-算法的伪代码描述"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 算法的伪代码描述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#维基百科中对归并排序的算法实现："><span class="toc-number">5.1.1.</span> <span class="toc-text">维基百科中对归并排序的算法实现：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Top-down-implementation"><span class="toc-number">5.1.1.1.</span> <span class="toc-text">Top-down implementation</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Bottom-up-implementation"><span class="toc-number">5.1.1.2.</span> <span class="toc-text">Bottom-up implementation</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Top-down-implementation-using-lists"><span class="toc-number">5.1.1.3.</span> <span class="toc-text">Top-down implementation using lists</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Bottom-up-implementation-using-lists"><span class="toc-number">5.1.1.4.</span> <span class="toc-text">Bottom-up implementation using lists</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-算法复杂度分析"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 算法复杂度分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-和其他排序算法的比较："><span class="toc-number">5.3.</span> <span class="toc-text">5.3 和其他排序算法的比较：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-归并排序图例演示"><span class="toc-number">5.4.</span> <span class="toc-text">5.4 归并排序图例演示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-对链表归并排序的示例"><span class="toc-number">5.5.</span> <span class="toc-text">5.5 对链表归并排序的示例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#合并两个有序的链表"><span class="toc-number">5.5.0.1.</span> <span class="toc-text">合并两个有序的链表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#使用归并排序对链表进行排序"><span class="toc-number">5.5.0.2.</span> <span class="toc-text">使用归并排序对链表进行排序</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#方法一"><span class="toc-number">5.5.0.2.1.</span> <span class="toc-text">方法一</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#方法二"><span class="toc-number">5.5.0.2.2.</span> <span class="toc-text">方法二</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-选择排序"><span class="toc-number">6.</span> <span class="toc-text">6. 选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-实现"><span class="toc-number">6.1.</span> <span class="toc-text">6.1 实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-分析"><span class="toc-number">6.2.</span> <span class="toc-text">6.2 分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-选择排序演示"><span class="toc-number">6.3.</span> <span class="toc-text">6.3 选择排序演示</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-堆排序"><span class="toc-number">7.</span> <span class="toc-text">7. 堆排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-实现"><span class="toc-number">7.1.</span> <span class="toc-text">7.1 实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-和其他排序算法的比较-Comparison-with-other-sorts"><span class="toc-number">7.2.</span> <span class="toc-text">7.2 和其他排序算法的比较(Comparison with other sorts)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-算法复杂度分析"><span class="toc-number">7.3.</span> <span class="toc-text">7.3 算法复杂度分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-堆排序演示"><span class="toc-number">7.4.</span> <span class="toc-text">7.4 堆排序演示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-堆排序的C-代码实现"><span class="toc-number">7.5.</span> <span class="toc-text">7.5 堆排序的C++代码实现</span></a></li></ol></li></div></div><div class="post-content"><p><strong>本文内容</strong>：</p>
<ul>
<li><input checked disabled type="checkbox"> 1.排序算法的分类  </li>
<li><input checked disabled type="checkbox"> 2.基于插入的排序  </li>
<li><input checked disabled type="checkbox"> 3.冒泡排序  </li>
<li><input checked disabled type="checkbox"> 4.快速排序  </li>
<li><input checked disabled type="checkbox"> 5.归并排序  </li>
<li><input checked disabled type="checkbox"> 6.选择排序  </li>
<li><input checked disabled type="checkbox"> 7.堆排序  </li>
</ul>
<h2 id="1-排序算法的分类"><a href="#1-排序算法的分类" class="headerlink" title="1. 排序算法的分类"></a>1. 排序算法的分类</h2><p>Sorting algorithms are often classified by: (<a href="https://en.wikipedia.org/wiki/Sorting_algorithm#Classification" target="_blank" rel="noopener">Reference link</a>)</p>
<ul>
<li>Computational complexity (worst, average and best behavior) in terms of the size of the list (n). For typical serial sorting algorithms good behavior is O(n log n), with parallel sort in O(log2 n), and bad behavior is O(n2). (See Big O notation.) Ideal behavior for a serial sort is O(n), but this is not possible in the average case. Optimal parallel sorting is O(log n). Comparison-based sorting algorithms, need at least O(n log n) comparisons for most inputs.</li>
<li>Computational complexity of swaps (for “in-place” algorithms).</li>
<li>Memory usage (and use of other computer resources). In particular, some sorting algorithms are “in-place”. Strictly, an in-place sort needs only O(1) memory beyond the items being sorted; sometimes O(log(n)) additional memory is considered “in-place”.</li>
<li>Recursion. Some algorithms are either recursive or non-recursive, while others may be both (e.g., merge sort).</li>
<li>Stability: stable sorting algorithms maintain the relative order of records with equal keys (i.e., values).</li>
<li>Whether or not they are a comparison sort. A comparison sort examines the data only by comparing two elements with a comparison operator.</li>
<li>General method: insertion, exchange, selection, merging, etc. Exchange sorts include bubble sort and quicksort. Selection sorts include shaker sort and heapsort. Also whether the algorithm is serial or parallel. The remainder of this discussion almost exclusively concentrates upon serial algorithms and assumes serial operation.</li>
<li>Adaptability: Whether or not the presortedness of the input affects the running time. Algorithms that take this into account are known to be adaptive.</li>
</ul>
<h3 id="1-1-稳定性"><a href="#1-1-稳定性" class="headerlink" title="1.1 稳定性"></a>1.1 稳定性</h3><p>排序算法的稳定性指的是，数组中相等元素在排序后，他们的相对位置不发生改变。<br>稳定排序算法的一个应用是：用第一和第二主键对数组进行排序。<br>比如对扑克牌，要求按数字大小进行排序，和按照花色进行排序（梅花、方块、红桃、黑桃），对于同一种花色，数字按照从小到大进行排序。第一轮按照数字从小到大进行排序（用任一种排序方法），第二轮用稳定的排序算法进行排序。<br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/79/Sorting_playing_cards_using_stable_sort.svg/400px-Sorting_playing_cards_using_stable_sort.svg.png" alt="image"></p>
<h3 id="1-2-排序算法的比较"><a href="#1-2-排序算法的比较" class="headerlink" title="1.2 排序算法的比较"></a>1.2 排序算法的比较</h3><p><a href="https://en.wikipedia.org/wiki/Sorting_algorithm#Comparison_of_algorithms" target="_blank" rel="noopener">参考链接（维基百科）</a></p>
<p><img src="http://img.blog.csdn.net/20160607144411150" alt="image"></p>
<h2 id="2-基于插入的排序算法"><a href="#2-基于插入的排序算法" class="headerlink" title="2. 基于插入的排序算法"></a>2. 基于插入的排序算法</h2><h3 id="2-1-直接插入排序"><a href="#2-1-直接插入排序" class="headerlink" title="2.1 直接插入排序"></a>2.1 直接插入排序</h3><p><a href="https://en.wikipedia.org/wiki/Insertion_sort" target="_blank" rel="noopener">Insertion sort</a> is a simple sorting algorithm that is relatively efficient for small lists and mostly sorted lists, and is often used as part of more sophisticated algorithms. It works by taking elements from the list one by one and inserting them in their correct position into a new sorted list.[17] In arrays, the new list and the remaining elements can share the array’s space, but insertion is expensive, requiring shifting all following elements over by one. Shell sort (see below) is a variant of insertion sort that is more efficient for larger lists.</p>
<p>It is much less efficient on large lists than more advanced algorithms such as quicksort, heapsort, or merge sort. However, insertion sort provides several advantages:</p>
<ul>
<li>Simple implementation: Bentley shows a three-line C version, and a five-line optimized version</li>
<li>Efficient for (quite) small data sets, much like other quadratic sorting algorithms</li>
<li>More efficient in practice than most other simple quadratic (i.e., O(n2)) algorithms such as selection sort or bubble sort</li>
<li>Adaptive, i.e., efficient for data sets that are already substantially sorted: the time complexity is O(nk) when each element in the input is no more than k places away from its sorted position</li>
<li>Stable; i.e., does not change the relative order of elements with equal keys</li>
<li>In-place; i.e., only requires a constant amount O(1) of additional memory space</li>
<li>Online; i.e., can sort a list as it receives it</li>
</ul>
<table>
<thead>
<tr>
<th align="left">Worst case performance</th>
<th align="left">О(n2) comparisons, swaps</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Best case performance</td>
<td align="left">O(n) comparisons, O(1) swaps</td>
</tr>
<tr>
<td align="left">Average case performance</td>
<td align="left">О(n2) comparisons, swaps</td>
</tr>
<tr>
<td align="left">Worst case space complexity</td>
<td align="left">О(n) total, O(1) auxiliary</td>
</tr>
</tbody></table>
<p>Insertion sort algorithm somewhat resembles selection sort. Array is imaginary divided into two parts - sorted one and unsorted one. At the beginning, sorted part contains first element of the array and unsorted one contains the rest. At every step, algorithm takes first element in the unsorted part and inserts it to the right place of the sorted one. When unsorted part becomes empty, algorithm stops. Sketchy, insertion sort algorithm step looks like this:</p>
<p><img src="http://www.algolist.net/img/sorts/insertion-sort-sketchy-before.png" alt="image"><br>becomes<br><img src="http://www.algolist.net/img/sorts/insertion-sort-sketchy-after.png" alt="image"></p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif" alt="image"></p>
<p>下面是插入排序的伪代码：（数组是从下标0开始的）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">INSERTION-SORT(A)</span><br><span class="line"><span class="keyword">for</span> j = <span class="number">1</span> to A.length</span><br><span class="line">    key = A[j]</span><br><span class="line">    <span class="comment">// Insert A[j] into the sorted sequence A[1..j-1]</span></span><br><span class="line">    i = j - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> A[i] &gt; key</span><br><span class="line">        A[i + <span class="number">1</span>] = A[i]</span><br><span class="line">        i = i - <span class="number">1</span></span><br><span class="line">    A[i + <span class="number">1</span>] = key</span><br></pre></td></tr></table></figure>

<p>C++语言实现（方法一：通过后移把元素放到正确的位置上）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> key = A[i];</span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; A[j] &gt; key) &#123;</span><br><span class="line">            A[j + <span class="number">1</span>] = A[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        A[j + <span class="number">1</span>] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C++语言实现（方法二：通过交换把元素放到正确的位置上）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertion_sort2</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    	<span class="keyword">int</span> j = i;	</span><br><span class="line">    	<span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; A[j - <span class="number">1</span>] &gt; A[j]) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = A[j - <span class="number">1</span>];	</span><br><span class="line">            A[j - <span class="number">1</span>] = A[j];</span><br><span class="line">            A[j] = temp;</span><br><span class="line">            j--;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对链表的直接插入排序"><a href="#对链表的直接插入排序" class="headerlink" title="对链表的直接插入排序"></a>对链表的直接插入排序</h3><p>If the items are stored in a linked list, then the list can be sorted with O(1) additional space. The algorithm starts with an initially empty (and therefore trivially sorted) list. The input items are taken off the list one at a time, and then inserted in the proper place in the sorted list. When the input list is empty, the sorted list has the desired result.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct LIST * <span class="title">SortList1</span><span class="params">(struct LIST * pList)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// zero or one element in list</span></span><br><span class="line">    <span class="keyword">if</span>(pList == <span class="literal">NULL</span> || pList-&gt;pNext == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> pList;</span><br><span class="line">    <span class="comment">// head is the first element of resulting sorted list</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LIST</span> * <span class="title">head</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(pList != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">LIST</span> * <span class="title">current</span> = <span class="title">pList</span>;</span></span><br><span class="line">        pList = pList-&gt;pNext;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span> || current-&gt;iValue &lt; head-&gt;iValue) &#123;</span><br><span class="line">            <span class="comment">// insert into the head of the sorted list</span></span><br><span class="line">            <span class="comment">// or as the first element into an empty sorted list</span></span><br><span class="line">            current-&gt;pNext = head;</span><br><span class="line">            head = current;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// insert current element into proper position in non-empty sorted list</span></span><br><span class="line">            struct LIST * p = head;</span><br><span class="line">            <span class="keyword">while</span>(p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;pNext == <span class="literal">NULL</span> || <span class="comment">// last element of the sorted list</span></span><br><span class="line">                   current-&gt;iValue &lt; p-&gt;pNext-&gt;iValue) <span class="comment">// middle of the list</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// insert into middle of the sorted list or as the last element</span></span><br><span class="line">                    current-&gt;pNext = p-&gt;pNext;</span><br><span class="line">                    p-&gt;pNext = current;</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// done</span></span><br><span class="line">                &#125;</span><br><span class="line">                p = p-&gt;pNext;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The algorithm below uses a trailing pointer[6] for the insertion into the sorted list. A simpler recursive method rebuilds the list each time (rather than splicing) and can use O(n) stack space.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LIST</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">LIST</span> * <span class="title">pNext</span>;</span></span><br><span class="line">  <span class="keyword">int</span>           iValue;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">struct LIST * <span class="title">SortList</span><span class="params">(struct LIST * pList)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// zero or one element in list</span></span><br><span class="line">  <span class="keyword">if</span>(!pList || !pList-&gt;pNext)</span><br><span class="line">      <span class="keyword">return</span> pList;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* build up the sorted array from the empty list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">LIST</span> * <span class="title">pSorted</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* take items off the input list one by one until empty */</span></span><br><span class="line">  <span class="keyword">while</span> (pList != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">/* remember the head */</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">LIST</span> *   <span class="title">pHead</span>  = <span class="title">pList</span>;</span></span><br><span class="line">      <span class="comment">/* trailing pointer for efficient splice */</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">LIST</span> ** <span class="title">ppTrail</span> = &amp;<span class="title">pSorted</span>;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* pop head off list */</span></span><br><span class="line">      pList = pList-&gt;pNext;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* splice head into sorted list at proper place */</span></span><br><span class="line">      <span class="keyword">while</span> (!(*ppTrail == <span class="literal">NULL</span> || pHead-&gt;iValue &lt; (*ppTrail)-&gt;iValue)) <span class="comment">/* does head belong here? */</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">/* no - continue down the list */</span></span><br><span class="line">          ppTrail = &amp;(*ppTrail)-&gt;pNext;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      pHead-&gt;pNext = *ppTrail;</span><br><span class="line">      *ppTrail = pHead;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pSorted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-希尔排序"><a href="#2-2-希尔排序" class="headerlink" title="2.2 希尔排序"></a>2.2 希尔排序</h3><p>Shellsort, named after its inventor, Donald Shell, relies upon the fact that insertion sort does very well if the array is nearly sorted. Another way of saying this, is that insertion sort does well if it does not have to move each item “too far”. The idea is to repeatedly do insertion sort on all elements at fixed, decreasing distances apart: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 这里的数学公式 $h_k, h_&#123;k-1&#125;, ..., h_1=1$</span><br><span class="line">// 用maupassant主题自带的LaTeX渲染会出问题，不能正常渲染</span><br><span class="line">h_k, h_&#123;k-1&#125;, ..., h_1 = 1</span><br></pre></td></tr></table></figure>

<p>The choice of increments turns out to be crucial. It turns out that a good choice of increments are these:<br>$h_1= 1, h_2= 3, h_3= 7, …, h_k= 2^k-1$<br>These increments are termed the Hibbard increments. The original increments suggested by the algorithm’s inventor were simple powers of 2, but the Hibbard increments do provably much better. To be able to use the $h_k$ increment, you need an array of size at least $h_k + 1$.</p>
<h4 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h4><p>The psuedo-code for shellSort using the Hibbard increments is as follows:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">find k0 so that <span class="number">2</span>^k0- <span class="number">1</span> &lt; size</span><br><span class="line"><span class="keyword">for</span> (k = k0; k &gt; <span class="number">0</span>; --k) &#123;  <span class="comment">// from larger increments to smaller</span></span><br><span class="line">    inc = <span class="number">2</span>^k- <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; inc; ++i) &#123;</span><br><span class="line">        Sort the elements ( a[i], a[i+inc], a[i+<span class="number">2</span>*inc], ...) <span class="keyword">using</span> insertionSort</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The fact that the last increment in the sequence is 1 means that regular insertion sort is done at the last step and therefore the array is guaranteed to be sorted by this procedure. The point is that when the increments are larger, there are fewer elements and they will be moved further than simply interchanging adjacent elements. At the last step, we do regular insertion sort and hopefully the array is “nearly sorted” which makes insertion sort come close to its best case behavior of running in linear time.</p>
<p>The notion that this is an speed improvement seems initially far-fetched. There are two enclosing for loops to get to an insertion sort, thus this algorithm has <strong>four enclosing loops</strong>.</p>
<h4 id="希尔排序的C-代码实现"><a href="#希尔排序的C-代码实现" class="headerlink" title="希尔排序的C++代码实现"></a>希尔排序的C++代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// find k0 so that 2^k0 - 1 &lt; n</span></span><br><span class="line">    <span class="keyword">int</span> k0 = <span class="built_in">std</span>::log2(n);</span><br><span class="line">    <span class="comment">// from larger increments to smaller</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = k0; k &gt; <span class="number">0</span>; --k) &#123;</span><br><span class="line">        <span class="keyword">int</span> inc = <span class="built_in">std</span>::<span class="built_in">pow</span>(<span class="number">2</span>, k) - <span class="number">1</span>;	</span><br><span class="line">        <span class="comment">// inc rounds insertion-sort</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inc; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + inc; j &lt; n; j += inc) &#123;</span><br><span class="line">                <span class="keyword">int</span> key = A[j];</span><br><span class="line">                <span class="keyword">int</span> m = j - inc; </span><br><span class="line">                <span class="keyword">while</span>(m &gt;= i &amp;&amp; A[m] &gt; key) &#123;</span><br><span class="line">                    A[m	+ inc] = A[m];</span><br><span class="line">                    m -= inc;</span><br><span class="line">                &#125;</span><br><span class="line">                A[m + inc] = key;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ShellSort-Analysis"><a href="#ShellSort-Analysis" class="headerlink" title="ShellSort Analysis"></a>ShellSort Analysis</h4><h5 id="Stability"><a href="#Stability" class="headerlink" title="Stability"></a>Stability</h5><p>Shellsort is <strong>not</strong> stable. It can be readily demonstrated with an array of size 4 (the smallest possible). Instability is to be expected because the increment-based sorts move elements distances without examining of elements in between.</p>
<h5 id="Shellsort-has-O-n-log-n-best-case-time"><a href="#Shellsort-has-O-n-log-n-best-case-time" class="headerlink" title="Shellsort has O(n*log(n)) best case time"></a>Shellsort has O(n*log(n)) best case time</h5><p>The best case, like insertion sort, is when the array is already sorted. Then the number of comparisons for each of the increment-based insertion sorts is the length of the array. Therefore we can determine:<br>comparisons =<br>   n, for 1 sort with elements 1-apart (last step) </p>
<ul>
<li>3 * n/3, for 3 sorts with elements 3-apart (next-to-last step) </li>
<li>7 * n/7, for 7 sorts with elements 7-apart </li>
<li>15 * n/15, for 15 sorts with elements 15-apart </li>
<li>…<br>Each term is n. The question is how many terms are there? The number of terms is the value k such that<br>2^k - l  &lt; n<br>So k &lt; log(n+1), meaning that the sorting time in the best case is less than n * log(n+1) = O(n*log(n)).</li>
</ul>
<h5 id="Shellsort-worst-case-time-is-no-worse-than-quadratic"><a href="#Shellsort-worst-case-time-is-no-worse-than-quadratic" class="headerlink" title="Shellsort worst case time is no worse than quadratic"></a>Shellsort worst case time is no worse than quadratic</h5><p>The argument is similar as previous, but with a different overall computation.<br>comparisons ≤<br>   n^2, for 1 sort with elements 1-apart (last step) </p>
<ul>
<li>3 * (n/3)^2, for 3 sorts with elements 3-apart (next-to-last step) </li>
<li>7 * (n/7)^2, for 7 sorts with elements 7-apart </li>
<li>15 * (n/15)^2, for 15 sorts with elements 15-apart </li>
<li>…<br>And so, with a bit of arithmetic, we can see that the number of comparisons is bounded by:<br>n^2 * (1 + 1/3 + 1/7 + 1/15 + 1/31 + …)<br>&lt; n^2 * (1 + 1/2 + 1/4 + 1/8 + 1/16 + …)<br>= n^2 * 2<br>The last step uses the sum of the geometric series.</li>
</ul>
<h5 id="Shellsort-worst-and-average-times"><a href="#Shellsort-worst-and-average-times" class="headerlink" title="Shellsort worst and average times"></a>Shellsort worst and average times</h5><p>The point about this algorithm is that the initial sorts, acting on elements at larger increments apart involve fewer elements, even considering a worst-case scenario. At these larger increments, “far-away” elements are swapped so that the number of inversions is dramatically reduced. At the later sorts of sorts at smaller increments, the behavior then comes closer to optimal behavior.<br>It can be proved that the worst-case time is sub-quadratic at $O(n^{3/2}) = O(n^{1.5}$<br>As can be expected, the proof is quite difficult. The textbook remarks that the average case time is unknown although conjectured to be $O(n^{5/4}) = O(n^{1.25})$<br>maybe it is (<a href="https://en.wikipedia.org/wiki/Shellsort" target="_blank" rel="noopener">from wikipedia</a>) $O(nlog^2n)$<br>The textbook also mentions other increment sequences which have been studied and seen to produce even better performance.</p>
<p>Reference Link: <a href="http://www.cs.wcupa.edu/rkline/ds/shell-comparison.html" target="_blank" rel="noopener">希尔排序</a></p>
<h2 id="3-冒泡排序"><a href="#3-冒泡排序" class="headerlink" title="3. 冒泡排序"></a>3. 冒泡排序</h2><p>Bubble sort, sometimes referred to as sinking sort, is a simple sorting algorithm that repeatedly steps through the list to be sorted, compares each pair of adjacent items and swaps them if they are in the wrong order. The pass through the list is repeated until no swaps are needed, which indicates that the list is sorted. The algorithm, which is a comparison sort, is named for the way smaller elements “bubble” to the top of the list. Although the algorithm is simple, it is too slow and impractical for most problems even when compared to insertion sort. It can be practical if the input is usually in sorted order but may occasionally have some out-of-order elements nearly in position.<br>注：正确的是顺序是小的在前，大的在后。</p>
<p>在输入规模较大时，冒泡排序的效率还不如插入排序，所以冒泡排序虽然简单，但是大多数时候并不使用它。</p>
<p>冒泡排序的演示如下图所示：<br><img src="https://upload.wikimedia.org/wikipedia/commons/c/c8/Bubble-sort-example-300px.gif" alt="image"></p>
<p>冒泡排序的C++实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[j] &gt; A[j + <span class="number">1</span>])	&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = A[j];</span><br><span class="line">                A[j] = A[j + <span class="number">1</span>];</span><br><span class="line">                A[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对冒泡排序常见的改进方法是加入一标志性变量exchange，用于标志某一趟排序过程中是否有数据交换，如果进行某一趟排序时并没有进行数据交换，则说明数据已经按要求排列好，可立即结束排序，避免不必要的比较过程。设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。<br>冒泡排序的改进一：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort2</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = n - <span class="number">1</span>;    <span class="comment">//初始时,最后位置保持不变 </span></span><br><span class="line">    <span class="keyword">while</span>(i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;  <span class="comment">//每趟开始时,无记录交换</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[j] &gt; A[j + <span class="number">1</span>])	&#123;</span><br><span class="line">                pos = j;	<span class="comment">//记录交换的位置</span></span><br><span class="line">                <span class="keyword">int</span> temp = A[j];</span><br><span class="line">                A[j] = A[j + <span class="number">1</span>];</span><br><span class="line">                A[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;	</span><br><span class="line">        i = pos;     <span class="comment">//为下一趟排序作准备</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="http://blog.csdn.net/hguisu/article/details/7776068" target="_blank" rel="noopener">八大排序算法</a>一文中，对冒泡排序算法做了另外的一种改进，如下代码所示，每一趟进行正反向的冒泡排序，同时找到最大值和最小值，<strong>不过我感觉此法并没有减少循环的次数</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort3</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> temp, i;</span><br><span class="line">    <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">for</span>(i = low; i &lt; high; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] &gt; A[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                temp = A[i];</span><br><span class="line">                A[i] = A[i + <span class="number">1</span>];</span><br><span class="line">                A[i + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;	</span><br><span class="line">        &#125;	</span><br><span class="line">        high--;</span><br><span class="line">        <span class="keyword">for</span>(i = high; i &gt; low; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i - <span class="number">1</span>] &gt; A[i]) &#123;</span><br><span class="line">                temp = A[i - <span class="number">1</span>];</span><br><span class="line">                A[i - <span class="number">1</span>] = A[i];</span><br><span class="line">                A[i] = temp;</span><br><span class="line">            &#125;	</span><br><span class="line">        &#125;	</span><br><span class="line">        low++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="冒泡排序算法复杂度分析"><a href="#冒泡排序算法复杂度分析" class="headerlink" title="冒泡排序算法复杂度分析"></a>冒泡排序算法复杂度分析</h4><table>
<thead>
<tr>
<th align="left">Data structure</th>
<th align="left">Array</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Best case performance</td>
<td align="left">O(n)</td>
</tr>
<tr>
<td align="left">Worst case performance</td>
<td align="left">O(n^2)</td>
</tr>
<tr>
<td align="left">Average case performance</td>
<td align="left">О(n^2)</td>
</tr>
<tr>
<td align="left">Worst case space complexity</td>
<td align="left">O(1) auxiliary</td>
</tr>
</tbody></table>
<h2 id="4-快速排序"><a href="#4-快速排序" class="headerlink" title="4. 快速排序"></a>4. 快速排序</h2><p>Quicksort (sometimes called partition-exchange sort) is an efficient sorting algorithm, serving as a systematic method for placing the elements of an array in order. Developed by Tony Hoare in 1959, with his work published in 1961, it is still a commonly used algorithm for sorting. When implemented well, it can be about two or three times faster than its main competitors, merge sort and heapsort.<a href="https://en.wikipedia.org/wiki/Quicksort" target="_blank" rel="noopener">Quicksort</a></p>
<p>The quicksort algorithm is another classic divide and conquer algorithm. Unlike merge-sort, which does merging after solving the two subproblems, quicksort does all its work upfront.</p>
<p>Quicksort is a comparison sort, meaning that it can sort items of any type for which a “less-than” relation (formally, a total order) is defined. In efficient implementations it is <strong>not a stable sort</strong>, meaning that the relative order of equal sort items is not preserved. Quicksort can operate in-place on an array, requiring small additional amounts of memory to perform the sorting.</p>
<p>Mathematical analysis of quicksort shows that, on average, the algorithm takes O(n log n) comparisons to sort n items. In the worst case, it makes O(n^2) comparisons, though this behavior is rare.</p>
<h3 id="4-1-快速排序的几种算法描述"><a href="#4-1-快速排序的几种算法描述" class="headerlink" title="4.1 快速排序的几种算法描述"></a>4.1 快速排序的几种算法描述</h3><h4 id="4-1-1-快速排序的描述和Java代码实现-Open-Data-Structures-in-Java"><a href="#4-1-1-快速排序的描述和Java代码实现-Open-Data-Structures-in-Java" class="headerlink" title="4.1.1 快速排序的描述和Java代码实现(Open Data Structures(in Java))"></a>4.1.1 快速排序的描述和Java代码实现(<a href="http://opendatastructures.org/versions/edition-0.1e/ods-java/11_1_Comparison_Based_Sorti.html#SECTION001412000000000000000" target="_blank" rel="noopener">Open Data Structures(in Java)</a>)</h4><p>Quicksort is simple to describe: Pick a random pivot element,  <code>x</code>, from array <code>A</code>; partition <code>A</code> into the set of elements less than  <code>x</code>, the set of elements equal to  <code>x</code>, and the set of elements greater than  <code>x</code>; and, finally, recursively sort the first and third sets in this partition. An example is shown in Figure.<br><img src="http://opendatastructures.org/versions/edition-0.1e/ods-java/img1399.png" alt="image"><br>An example execution of <code>quickSort(a,0,14,c)</code></p>
<p>Java代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(T[] a, Comparator&lt;T&gt; c)</span> </span>&#123;</span><br><span class="line">    quickSort(a, <span class="number">0</span>, a.length, c);</span><br><span class="line">&#125;</span><br><span class="line">&lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(T[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> n, Comparator&lt;T&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    T x = a[i + rand.nextInt(n)];</span><br><span class="line">    <span class="keyword">int</span> p = i-<span class="number">1</span>, j = i, q = i+n;</span><br><span class="line">    <span class="comment">// a[i..p]&lt;x,  a[p+1..q-1]??x, a[q..i+n-1]&gt;x </span></span><br><span class="line">    <span class="keyword">while</span> (j &lt; q) &#123;</span><br><span class="line">        <span class="keyword">int</span> comp = compare(a[j], x);</span><br><span class="line">        <span class="keyword">if</span> (comp &lt; <span class="number">0</span>) &#123;       <span class="comment">// move to beginning of array</span></span><br><span class="line">            swap(a, j++, ++p);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (comp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            swap(a, j, --q);  <span class="comment">// move to end of array</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j++;              <span class="comment">// keep in the middle</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// a[i..p]&lt;x,  a[p+1..q-1]=x, a[q..i+n-1]&gt;x </span></span><br><span class="line">    quickSort(a, i, p-i+<span class="number">1</span>, c);</span><br><span class="line">    quickSort(a, q, n-(q-i), c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-1-2-算法导论一书中第7章快速排序的描述"><a href="#4-1-2-算法导论一书中第7章快速排序的描述" class="headerlink" title="4.1.2 算法导论一书中第7章快速排序的描述"></a>4.1.2 算法导论一书中第7章快速排序的描述</h4><p><strong><a href="https://en.wikipedia.org/wiki/Quicksort#Lomuto_partition_scheme" target="_blank" rel="noopener">Lomuto partition scheme</a></strong></p>
<p>This scheme is attributed to Nico Lomuto and popularized by Bentley in his book Programming Pearls and Cormen et al. in their book <strong>Introduction to Algorithms</strong>. This scheme chooses a pivot which is typically the last element in the array. The algorithm maintains the index to put the pivot in variable i and each time it finds an element less than or equal to pivot, this index is incremented and that element would be placed before the pivot. As this scheme is more compact and easy to understand, it is frequently used in introductory material, although it is less efficient than Hoare’s original scheme. This scheme degrades to O(n^2) when the array is already sorted as well as when the array has all equal elements. There have been various variants proposed to boost performance including various ways to select pivot, deal with equal elements, use other sorting algorithms such as Insertion sort for small arrays and so on.</p>
<p>与归并排序一样，快速排序也使用了分治思想。下面是对一个典型的子数组A[p..r]进行快速排序的三步分治过程：</p>
<p><strong>分解</strong>：数组A[p..r]被划分为两个（可能为空）子数组A[p..q-1]和A[q+1..r]，使得A[p..q-1]中的每一个元素都小于等于A[q],而A[q]也小于等于A[q+1..r]中的每个元素。其中，计算下标q也是划分过程的一部分。<br><strong>解决</strong>：通过递归调用快速排序，对子数组A[p..q-1]和A[q+1..r]进行排序。<br><strong>合并</strong>：因为子数组都是原址排序的，所以不需要合并操作：数组A[p..r]已经有序。</p>
<p>假设数组的下标从0开始，算法的伪代码如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">QUICKSORT(A, p, r)</span><br><span class="line"><span class="keyword">if</span> p &lt; r</span><br><span class="line">    q = PARTITION(A, p, r)</span><br><span class="line">    QUICKSORT(A, p, q - <span class="number">1</span>)</span><br><span class="line">    QUICKSORT(A, q + <span class="number">1</span>, r)</span><br><span class="line">    </span><br><span class="line">PARTITION(A, p, r)</span><br><span class="line">x = A[r]</span><br><span class="line">i = p - <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> j = p to r - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> A[j] &lt;= x</span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">        exchange A[i] with A[j]</span><br><span class="line">exchange A[i + <span class="number">1</span>] with A[r]</span><br><span class="line"><span class="keyword">return</span> i + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>在<code>PARTITION</code>的最后两行中，通过将主元与最左的大于x的元素进行交换，就可以将主元移动到它在数组中的正确位置上，并返回主元的新下标。<br><code>PARTITION</code>在子数组A[p..r]上的时间复杂度是<code>O(n)</code>,其中<code>n=r-p+1</code>。</p>
<p>C++代码实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">    &gt; File Name: quick_sort.cpp</span></span><br><span class="line"><span class="comment">    &gt; Author: qiaoyihan</span></span><br><span class="line"><span class="comment">    &gt; Email: yihqiao@126.com</span></span><br><span class="line"><span class="comment">    &gt; Created Time: Sun Aug  7 16:29:48 2016</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> QuickSort::swap(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> QuickSort::quick_sort(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> q = partition(A, left, right);	</span><br><span class="line">        quick_sort(A, left, q - <span class="number">1</span>);</span><br><span class="line">        quick_sort(A, q + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> QuickSort::partition(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> x = A[right];</span><br><span class="line">    <span class="keyword">int</span> i = left - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = left; j &lt; right; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[j] &lt;= x) &#123;</span><br><span class="line">            i = i + <span class="number">1</span>;</span><br><span class="line">            swap(A[i], A[j]);</span><br><span class="line">        &#125;	</span><br><span class="line">    &#125;</span><br><span class="line">    swap(A[i + <span class="number">1</span>], A[right]);</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> QuickSort::quick_sort(<span class="keyword">int</span> A[], <span class="keyword">int</span> n) </span><br><span class="line">&#123;</span><br><span class="line">    quick_sort(A, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[] = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">38</span>, <span class="number">7</span>, <span class="number">19</span>, <span class="number">8</span>, <span class="number">27</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    QuickSort *pQuickSort = <span class="keyword">new</span> QuickSort();</span><br><span class="line">    pQuickSort-&gt;quick_sort(A, n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> e : A) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="string">" "</span>;	</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>  </p>
<p>在讨论快速排序的平均性能时，我们假设输入序列的所有排列都是等概率的，这个假设并不总是成立，很多人都选择随机化版本的快速排序作为大数据输入情况下的排序算法。</p>
<p>在随机化的快速排序算法中，我们只需要在随机选择了枢轴元素后，把数组的最后一个元素和枢轴元素交换，这样的话我们就又可以利用上面的算法了。</p>
<h4 id="4-1-3-Hoare-partition-scheme"><a href="#4-1-3-Hoare-partition-scheme" class="headerlink" title="4.1.3 Hoare partition scheme"></a>4.1.3 <a href="https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme" target="_blank" rel="noopener">Hoare partition scheme</a></h4><p>The original partition scheme described by C.A.R. Hoare uses two indices that start at the ends of the array being partitioned, then move toward each other, until they detect an inversion: a pair of elements, one greater than the pivot, one smaller, that are in the wrong order relative to each other. The inverted elements are then swapped. When the indices meet, the algorithm stops and returns the final index. There are many variants of this algorithm, for example, selecting pivot from A[hi] instead of A[lo]. <strong>Hoare’s scheme is more efficient than Lomuto’s partition scheme because it does three times fewer swaps on average, and it creates efficient partitions even when all values are equal.</strong> Like Lomuto’s partition scheme, Hoare partitioning also causes Quicksort to degrade to O(n^2) when the input array is already sorted; it also doesn’t produce a stable sort. <strong>Note that in this scheme, the pivot’s final location is not necessarily at the index that was returned</strong>, and the next two segments that the main algorithm recurs on are [lo..p] and (p..hi] as opposed to [lo..p) and (p..hi] as in Lomuto’s scheme. In pseudocode,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">algorithm quicksort(A, lo, hi) is</span><br><span class="line">    if lo &lt; hi then</span><br><span class="line">        p := partition(A, lo, hi)</span><br><span class="line">        quicksort(A, lo, p)</span><br><span class="line">        quicksort(A, p + 1, hi)</span><br><span class="line"></span><br><span class="line">algorithm partition(A, lo, hi) is</span><br><span class="line">    pivot := A[lo]</span><br><span class="line">    i := lo – 1</span><br><span class="line">    j := hi + 1</span><br><span class="line">    loop forever</span><br><span class="line">        do</span><br><span class="line">            i := i + 1</span><br><span class="line">        while A[i] &lt; pivot</span><br><span class="line">        </span><br><span class="line">        do</span><br><span class="line">            j := j – 1</span><br><span class="line">        while A[j] &gt; pivot</span><br><span class="line">        </span><br><span class="line">        if i &gt;= j then</span><br><span class="line">            return j</span><br><span class="line">        </span><br><span class="line">        swap A[i] with A[j]</span><br></pre></td></tr></table></figure>

<p>C++代码实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> QuickSort::swap(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> QuickSort::quick_sort(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> p = partition(A, left, right);	</span><br><span class="line">        quick_sort(A, left, p);</span><br><span class="line">        quick_sort(A, p + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> QuickSort::partition(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = A[left];</span><br><span class="line">    <span class="keyword">int</span> i = left - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = right + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            i = i + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span>(A[i] &lt; pivot);	</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            j = j - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span>(A[j] &gt; pivot);	</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i &gt;= j)</span><br><span class="line">            <span class="keyword">return</span> j;</span><br><span class="line"></span><br><span class="line">        swap(A[i], A[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> QuickSort::quick_sort(<span class="keyword">int</span> A[], <span class="keyword">int</span> n) </span><br><span class="line">&#123;</span><br><span class="line">    quick_sort(A, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[] = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">38</span>, <span class="number">7</span>, <span class="number">19</span>, <span class="number">8</span>, <span class="number">27</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    QuickSort *pQuickSort = <span class="keyword">new</span> QuickSort();</span><br><span class="line">    pQuickSort-&gt;quick_sort(A, n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> e : A) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="string">" "</span>;	</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<p>上面提到的 Hoare partition scheme 和 Lomuto partition scheme 的算法在改变了枢轴元素的位置后，算法的代码要做相应的改变，比较简单的做法是，像快排的随机化版本那样，交换枢轴元素到第一个或最后一个元素的位置处。下面是 Hoare partition scheme 算法的一个变体，该算法较易明白，而且用元素的赋值代替了交换操作，如果取枢轴元素为最后一个的话，需要先从<code>low</code>考虑小于枢轴元素的情况，再从<code>high</code>考虑大于枢轴元素的情况。如果取枢轴元素为第一个的话，需要先从<code>high</code>考虑大于枢轴元素的情况，再从<code>low</code>考虑小于枢轴元素的情况。<br>算法的C++实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> low = left;</span><br><span class="line">        <span class="keyword">int</span> high = right;</span><br><span class="line">        <span class="keyword">int</span> x = A[high];   <span class="comment">// 记录最后一个元素为枢轴元素</span></span><br><span class="line">        <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">while</span>(low &lt; high &amp;&amp; A[low] &lt; x)	</span><br><span class="line">                low++;</span><br><span class="line">            <span class="keyword">if</span>(low &lt; high) &#123;</span><br><span class="line">                A[high] = A[low];</span><br><span class="line">                high--;</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="keyword">while</span>(low &lt; high &amp;&amp; A[high] &gt; x)	</span><br><span class="line">                high--;</span><br><span class="line">            <span class="keyword">if</span>(low &lt; high) &#123;</span><br><span class="line">                A[low] = A[high];</span><br><span class="line">                low++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        A[high] = x;</span><br><span class="line">        quick_sort(A, left, low - <span class="number">1</span>);</span><br><span class="line">        quick_sort(A, low + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    quick_sort(A, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-快速排序的算法复杂度分析"><a href="#4-2-快速排序的算法复杂度分析" class="headerlink" title="4.2 快速排序的算法复杂度分析"></a>4.2 快速排序的算法复杂度分析</h3><table>
<thead>
<tr>
<th align="left">Data structure</th>
<th align="left">Array</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Best case performance</td>
<td align="left">O(n log n) (simple partition) or O(n) (three-way partition and equal keys)</td>
</tr>
<tr>
<td align="left">Worst case performance</td>
<td align="left">O(n^2)</td>
</tr>
<tr>
<td align="left">Average case performance</td>
<td align="left">O(n log n)</td>
</tr>
<tr>
<td align="left">Worst case space complexity</td>
<td align="left">O(n) auxiliary (naive), O(log n) auxiliary (Sedgewick 1978)</td>
</tr>
</tbody></table>
<h2 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5. 归并排序"></a>5. 归并排序</h2><p><strong>Definition</strong>: A sort algorithm that splits the items to be sorted into two groups, recursively sorts each group, and merges them into a final, sorted sequence. Run time is Θ(n log n).</p>
<p>Conceptually, a merge sort works as follows:</p>
<p>1) Divide the unsorted list into n sublists, each containing 1 element (a list of 1 element is considered sorted).</p>
<p>2) Repeatedly merge sublists to produce new sorted sublists until there is only 1 sublist remaining. This will be the sorted list.</p>
<h3 id="5-1-算法的伪代码描述"><a href="#5-1-算法的伪代码描述" class="headerlink" title="5.1 算法的伪代码描述"></a>5.1 算法的伪代码描述</h3><p>归并排序的的关键是合并两个已经排好序的数组，假设子数组<code>A[p ... q]</code>和<code>A[q+1 ... r]</code>已经排好序，下面的算法是合并这两个子数组及归并排序。<br>这里的伪代码为算法导论一书中的归并排序算法改进而来。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">MERGE(A, p, q, r)</span><br><span class="line">n1 = q - p + <span class="number">1</span></span><br><span class="line">n2 = r - q</span><br><span class="line">let L[<span class="number">1.</span>..n1 + <span class="number">1</span>] <span class="keyword">and</span> R[<span class="number">1.</span>..n2 + <span class="number">1</span>] be <span class="keyword">new</span> arrays</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span> to n1</span><br><span class="line">    L[i] = A[p + i - <span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> j = <span class="number">1</span> to n2</span><br><span class="line">    R[j] = A[q + j]</span><br><span class="line">i = <span class="number">1</span></span><br><span class="line">j = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> k = p to r</span><br><span class="line">    <span class="keyword">if</span> i &lt; n1 + <span class="number">1</span> <span class="keyword">and</span> j &lt; n2 + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> L[i] &lt;= R[j]</span><br><span class="line">            A[k] = L[i]</span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            A[k] = R[j]</span><br><span class="line">            j = j + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> i &lt; n1 + <span class="number">1</span></span><br><span class="line">        A[k] = L[i]</span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> j &lt; n2 + <span class="number">1</span></span><br><span class="line">            A[k] = R[j]</span><br><span class="line">            j = j + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">MERGE-SORT(A, p, r)</span><br><span class="line"><span class="keyword">if</span> p &lt; r</span><br><span class="line">    q = (p + r) / <span class="number">2</span></span><br><span class="line">    MERGE-SORT(A, p, q)</span><br><span class="line">    MERGE-SORT(A, q + <span class="number">1</span>, r)</span><br><span class="line">    MERGE(A, p, q, r)</span><br></pre></td></tr></table></figure>

<h4 id="维基百科中对归并排序的算法实现："><a href="#维基百科中对归并排序的算法实现：" class="headerlink" title="维基百科中对归并排序的算法实现："></a>维基百科中对归并排序的算法实现：</h4><h5 id="Top-down-implementation"><a href="#Top-down-implementation" class="headerlink" title="Top-down implementation"></a>Top-down implementation</h5><p>Example C-like code using indices for top down merge sort algorithm that recursively splits the list (called runs in this example) into sublists until sublist size is 1, then merges those sublists to produce a sorted list. The copy back step could be avoided if the recursion alternated between two functions so that the direction of the merge corresponds with the level of recursion.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Array A[] has the items to sort; array B[] is a work array.</span></span><br><span class="line">TopDownMergeSort(A[], B[], n)</span><br><span class="line">&#123;</span><br><span class="line">    TopDownSplitMerge(A, <span class="number">0</span>, n, B);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// iBegin is inclusive; iEnd is exclusive (A[iEnd] is not in the set).</span></span><br><span class="line">TopDownSplitMerge(A[], iBegin, iEnd, B[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(iEnd - iBegin &lt; <span class="number">2</span>)                       <span class="comment">// if run size == 1</span></span><br><span class="line">        <span class="keyword">return</span>;                                 <span class="comment">//   consider it sorted</span></span><br><span class="line">    <span class="comment">// recursively split runs into two halves until run size == 1,</span></span><br><span class="line">    <span class="comment">// then merge them and return back up the call chain</span></span><br><span class="line">    iMiddle = (iEnd + iBegin) / <span class="number">2</span>;              <span class="comment">// iMiddle = mid point</span></span><br><span class="line">    TopDownSplitMerge(A, iBegin,  iMiddle, B);  <span class="comment">// split / merge left  half</span></span><br><span class="line">    TopDownSplitMerge(A, iMiddle,    iEnd, B);  <span class="comment">// split / merge right half</span></span><br><span class="line">    TopDownMerge(A, iBegin, iMiddle, iEnd, B);  <span class="comment">// merge the two half runs</span></span><br><span class="line">    CopyArray(B, iBegin, iEnd, A);              <span class="comment">// copy the merged runs back to A</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Left half is A[iBegin:iMiddle-1].</span></span><br><span class="line"><span class="comment">// Right half is A[iMiddle:iEnd-1   ].</span></span><br><span class="line">TopDownMerge(A[], iBegin, iMiddle, iEnd, B[])</span><br><span class="line">&#123;</span><br><span class="line">    i = iBegin, j = iMiddle;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// While there are elements in the left or right runs...</span></span><br><span class="line">    <span class="keyword">for</span> (k = iBegin; k &lt; iEnd; k++) &#123;</span><br><span class="line">        <span class="comment">// If left run head exists and is &lt;= existing right run head.</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; iMiddle &amp;&amp; (j &gt;= iEnd || A[i] &lt;= A[j])) &#123;</span><br><span class="line">            B[k] = A[i];</span><br><span class="line">            i = i + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            B[k] = A[j];</span><br><span class="line">            j = j + <span class="number">1</span>;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CopyArray(B[], iBegin, iEnd, A[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(k = iBegin; k &lt; iEnd; k++)</span><br><span class="line">        A[k] = B[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Bottom-up-implementation"><a href="#Bottom-up-implementation" class="headerlink" title="Bottom-up implementation"></a>Bottom-up implementation</h5><p>Example C-like code using indices for bottom up merge sort algorithm which treats the list as an array of n sublists (called runs in this example) of size 1, and iteratively merges sub-lists back and forth between two buffers:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array A[] has the items to sort; array B[] is a work array</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BottomUpMergeSort</span><span class="params">(A[], B[], n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// Each 1-element run in A is already "sorted".</span></span><br><span class="line">  <span class="comment">// Make successively longer sorted runs of length 2, 4, 8, 16... until whole array is sorted.</span></span><br><span class="line">  <span class="keyword">for</span> (width = <span class="number">1</span>; width &lt; n; width = <span class="number">2</span> * width)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// Array A is full of runs of length width.</span></span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i = i + <span class="number">2</span> * width)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// Merge two runs: A[i:i+width-1] and A[i+width:i+2*width-1] to B[]</span></span><br><span class="line">          <span class="comment">// or copy A[i:n-1] to B[] ( if(i+width &gt;= n) )</span></span><br><span class="line">          BottomUpMerge(A, i, min(i+width, n), min(i+<span class="number">2</span>*width, n), B);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// Now work array B is full of runs of length 2*width.</span></span><br><span class="line">      <span class="comment">// Copy array B to array A for next iteration.</span></span><br><span class="line">      <span class="comment">// A more efficient implementation would swap the roles of A and B.</span></span><br><span class="line">      CopyArray(B, A, n);</span><br><span class="line">      <span class="comment">// Now array A is full of runs of length 2*width.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Left run is A[iLeft :iRight-1].</span></span><br><span class="line"><span class="comment">// Right run is A[iRight:iEnd-1  ].</span></span><br><span class="line">BottomUpMerge(A[], iLeft, iRight, iEnd, B[])</span><br><span class="line">&#123;</span><br><span class="line">    i = iLeft, j = iRight;</span><br><span class="line">    <span class="comment">// While there are elements in the left or right runs...</span></span><br><span class="line">    <span class="keyword">for</span> (k = iLeft; k &lt; iEnd; k++) &#123;</span><br><span class="line">        <span class="comment">// If left run head exists and is &lt;= existing right run head.</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; iRight &amp;&amp; (j &gt;= iEnd || A[i] &lt;= A[j])) &#123;</span><br><span class="line">            B[k] = A[i];</span><br><span class="line">            i = i + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            B[k] = A[j];</span><br><span class="line">            j = j + <span class="number">1</span>;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CopyArray</span><span class="params">(B[], A[], n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        A[i] = B[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Top-down-implementation-using-lists"><a href="#Top-down-implementation-using-lists" class="headerlink" title="Top-down implementation using lists"></a>Top-down implementation using lists</h5><p>Pseudocode for top down merge sort algorithm which recursively divides the input list into smaller sublists until the sublists are trivially sorted, and then merges the sublists while returning up the call chain.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function merge_sort(list m)</span><br><span class="line">    // Base case. A list of zero or one elements is sorted, by definition.</span><br><span class="line">    if length of m ≤ 1 then</span><br><span class="line">        return m</span><br><span class="line"></span><br><span class="line">    // Recursive case. First, divide the list into equal-sized sublists</span><br><span class="line">    // consisting of the even and odd-indexed elements.</span><br><span class="line">    var left := empty list</span><br><span class="line">    var right := empty list</span><br><span class="line">    for each x with index i in m do</span><br><span class="line">        if i is odd then</span><br><span class="line">            add x to left</span><br><span class="line">        else</span><br><span class="line">            add x to right</span><br><span class="line"></span><br><span class="line">    // Recursively sort both sublists.</span><br><span class="line">    left := merge_sort(left)</span><br><span class="line">    right := merge_sort(right)</span><br><span class="line"></span><br><span class="line">    // Then merge the now-sorted sublists.</span><br><span class="line">    return merge(left, right)</span><br></pre></td></tr></table></figure>

<p>In this example, the merge function merges the left and right sublists.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function merge(left, right)</span><br><span class="line">    var result := empty list</span><br><span class="line"></span><br><span class="line">    while left is not empty and right is not empty do</span><br><span class="line">        if first(left) ≤ first(right) then</span><br><span class="line">            append first(left) to result</span><br><span class="line">            left := rest(left)</span><br><span class="line">        else</span><br><span class="line">            append first(right) to result</span><br><span class="line">            right := rest(right)</span><br><span class="line"></span><br><span class="line">    // Either left or right may have elements left; consume them.</span><br><span class="line">    // (Only one of the following loops will actually be entered.)</span><br><span class="line">    while left is not empty do</span><br><span class="line">        append first(left) to result</span><br><span class="line">        left := rest(left)</span><br><span class="line">    while right is not empty do</span><br><span class="line">        append first(right) to result</span><br><span class="line">        right := rest(right)</span><br><span class="line">    return result</span><br></pre></td></tr></table></figure>

<h5 id="Bottom-up-implementation-using-lists"><a href="#Bottom-up-implementation-using-lists" class="headerlink" title="Bottom-up implementation using lists"></a>Bottom-up implementation using lists</h5><p>Pseudocode for bottom up merge sort algorithm which uses a small fixed size array of references to nodes, where array[i] is either a reference to a list of size 2^i or 0. node is a reference or pointer to a node. The merge() function would be similar to the one shown in the top down merge lists example, it merges two already sorted lists, and handles empty lists. In this case, merge() would use node for its input parameters and return value.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function merge_sort(node head)</span><br><span class="line">    // return if empty list</span><br><span class="line">    if (head == nil)</span><br><span class="line">        return nil</span><br><span class="line">    var node array[32]; initially all nil</span><br><span class="line">    var node result</span><br><span class="line">    var node next</span><br><span class="line">    var int  i</span><br><span class="line">    result = head</span><br><span class="line">    // merge nodes into array</span><br><span class="line">    while (result != nil)</span><br><span class="line">         next = result.next;</span><br><span class="line">         result.next = nil</span><br><span class="line">         for(i = 0; (i &lt; 32) &amp;&amp; (array[i] != nil); i += 1)</span><br><span class="line">              result = merge(array[i], result)</span><br><span class="line">              array[i] = nil</span><br><span class="line">         // do not go past end of array</span><br><span class="line">         if (i == 32)</span><br><span class="line">               i -= 1</span><br><span class="line">         array[i] = result</span><br><span class="line">         result = next</span><br><span class="line">    // merge array into single list</span><br><span class="line">    result = nil</span><br><span class="line">    for (i = 0; i &lt; 32; i += 1)</span><br><span class="line">         result = merge(array[i], result)</span><br><span class="line">    return result</span><br></pre></td></tr></table></figure>

<h3 id="5-2-算法复杂度分析"><a href="#5-2-算法复杂度分析" class="headerlink" title="5.2 算法复杂度分析"></a>5.2 算法复杂度分析</h3><table>
<thead>
<tr>
<th align="left">Data structure</th>
<th align="left">Array</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Best case performance</td>
<td align="left">O(n log n) typical, O(n) natural variant</td>
</tr>
<tr>
<td align="left">Worst case performance</td>
<td align="left">O(n log n)</td>
</tr>
<tr>
<td align="left">Average case performance</td>
<td align="left">O(n log n)</td>
</tr>
<tr>
<td align="left">Worst case space complexity</td>
<td align="left">О(n) total, O(n) auxiliary</td>
</tr>
</tbody></table>
<h3 id="5-3-和其他排序算法的比较："><a href="#5-3-和其他排序算法的比较：" class="headerlink" title="5.3 和其他排序算法的比较："></a>5.3 和其他排序算法的比较：</h3><p>Although heapsort has the same time bounds as merge sort, it requires only Θ(1) auxiliary space instead of merge sort’s Θ(n). On typical modern architectures, efficient quicksort implementations generally outperform mergesort for sorting RAM-based arrays.[citation needed] On the other hand, merge sort is a stable sort and is more efficient at handling slow-to-access sequential media. Merge sort is often the best choice for sorting a linked list: in this situation it is relatively easy to implement a merge sort in such a way that it requires only Θ(1) extra space, and the slow random-access performance of a linked list makes some other algorithms (such as quicksort) perform poorly, and others (such as heapsort) completely impossible.</p>
<p>As of Perl 5.8, merge sort is its default sorting algorithm (it was quicksort in previous versions of Perl). In Java, the Arrays.sort() methods use merge sort or a tuned quicksort depending on the datatypes and for implementation efficiency switch to insertion sort when fewer than seven array elements are being sorted. Python uses Timsort, another tuned hybrid of merge sort and insertion sort, that has become the standard sort algorithm in Java SE 7, on the Android platform, and in GNU Octave.</p>
<h3 id="5-4-归并排序图例演示"><a href="#5-4-归并排序图例演示" class="headerlink" title="5.4 归并排序图例演示"></a>5.4 归并排序图例演示</h3><p><img src="http://img.blog.csdn.net/20160517150920429" alt="image"></p>
<h3 id="5-5-对链表归并排序的示例"><a href="#5-5-对链表归并排序的示例" class="headerlink" title="5.5 对链表归并排序的示例"></a>5.5 对链表归并排序的示例</h3><h5 id="合并两个有序的链表"><a href="#合并两个有序的链表" class="headerlink" title="合并两个有序的链表"></a>合并两个有序的链表</h5><p>要求：使用常量的额外空间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/********************************************************************************** </span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* Merge two sorted linked lists and return it as a new list. The new list should be </span></span><br><span class="line"><span class="comment">* made by splicing together the nodes of the first two lists.</span></span><br><span class="line"><span class="comment">*               </span></span><br><span class="line"><span class="comment">**********************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Solution()&#123;</span><br><span class="line">        srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode *<span class="title">mergeTwoLists</span><span class="params">(ListNode *l1, ListNode *l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (random()%<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> mergeTwoLists01(l1, l2);</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> mergeTwoLists02(l1, l2);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> mergeTwoLists03(l1, l2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* merge the 2nd list into 1st list*/</span></span><br><span class="line">    <span class="function">ListNode *<span class="title">mergeTwoLists01</span><span class="params">(ListNode* head1, ListNode* head2)</span></span>&#123;</span><br><span class="line">        ListNode *p1 = head1,  *p2=head2;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> ListNode <span class="title">dummy</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">        dummy.next = p1;</span><br><span class="line">        ListNode *prev = &amp;dummy;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span>(p1 &amp;&amp; p2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p1-&gt;val &lt; p2-&gt;val)&#123;</span><br><span class="line">                prev = p1;</span><br><span class="line">                p1 = p1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                prev-&gt;next = p2;</span><br><span class="line">                p2 = p2-&gt;next;</span><br><span class="line">                prev = prev-&gt;next;</span><br><span class="line">                prev-&gt;next = p1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p2)&#123;</span><br><span class="line">            prev-&gt;next = p2;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* merge two lists to the new list */</span></span><br><span class="line">    <span class="function">ListNode *<span class="title">mergeTwoLists02</span><span class="params">(ListNode *l1, ListNode *l2)</span> </span>&#123;</span><br><span class="line">        ListNode *l=<span class="literal">NULL</span>, *p=<span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (l1!=<span class="literal">NULL</span> &amp;&amp; l2!=<span class="literal">NULL</span> )&#123;</span><br><span class="line">            ListNode *n=<span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt; val)&#123;</span><br><span class="line">                n = l1;</span><br><span class="line">                l1=l1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                n = l2;</span><br><span class="line">                l2=l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l==<span class="literal">NULL</span>)&#123;</span><br><span class="line">                l = p = n;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p-&gt;next = n;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode* rest = l1 ? l1 :l2;</span><br><span class="line">        </span><br><span class="line">        l = mergeTheRest(rest, l, p);</span><br><span class="line">       </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTheRest</span><span class="params">(ListNode* l, ListNode*head, ListNode* tail)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l)&#123;</span><br><span class="line">            <span class="keyword">if</span> (head &amp;&amp; tail )&#123;</span><br><span class="line">                tail-&gt;next = l;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                head = l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  </span></span><br><span class="line"><span class="comment">     * You can see the 2nd slution's code is quite complicated, </span></span><br><span class="line"><span class="comment">     * because it need to check the (head==NULL) situation.</span></span><br><span class="line"><span class="comment">     * We can use the "pointer to pointer" to make the code more clean</span></span><br><span class="line"><span class="comment">     * however, this would be bad for performance.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ListNode *<span class="title">mergeTwoLists03</span><span class="params">(ListNode *l1, ListNode *l2)</span> </span>&#123;</span><br><span class="line">        ListNode *head = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode **pTail = &amp;head;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">NULL</span> &amp;&amp; l2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">                *pTail = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                *pTail = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            pTail = &amp;(*pTail)-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        *pTail = (l1 != <span class="literal">NULL</span> ? l1 : l2);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="使用归并排序对链表进行排序"><a href="#使用归并排序对链表进行排序" class="headerlink" title="使用归并排序对链表进行排序"></a>使用归并排序对链表进行排序</h5><h6 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mergeSort(head);    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeSort</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">            </span><br><span class="line">        <span class="function">ListNode <span class="title">dummy1</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">ListNode <span class="title">dummy2</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        ListNode *left = &amp;dummy1;</span><br><span class="line">        ListNode *right = &amp;dummy2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i++ % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                left-&gt;next = head;</span><br><span class="line">                left = left-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right-&gt;next = head;</span><br><span class="line">                right = right-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        left-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        right-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        left = dummy1.next;</span><br><span class="line">        right = dummy2.next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* left, ListNode* right)</span> </span>&#123;</span><br><span class="line">        ListNode *p1 = left, *p2 = right;</span><br><span class="line">        <span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        ListNode *tail = &amp;dummy;</span><br><span class="line">        <span class="keyword">while</span>(p1 &amp;&amp; p2) &#123;</span><br><span class="line">            <span class="keyword">if</span>(p1-&gt;val &lt; p2-&gt;val) &#123;</span><br><span class="line">                tail-&gt;next = p1;</span><br><span class="line">                p1 = p1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail-&gt;next = p2;</span><br><span class="line">                p2 = p2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p1) tail-&gt;next = p1;</span><br><span class="line">        <span class="keyword">if</span>(p2) tail-&gt;next = p2;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h6 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/********************************************************************************** </span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* Sort a linked list in O(n log n) time using constant space complexity.</span></span><br><span class="line"><span class="comment">*               </span></span><br><span class="line"><span class="comment">**********************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode *<span class="title">mergeTwoLists</span><span class="params">(ListNode* head1, ListNode* head2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode *<span class="title">sortList</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head==<span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//find the middle place</span></span><br><span class="line">    ListNode *p1=head, *p2=head-&gt;next; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p2 &amp;&amp; p2-&gt;next)&#123;</span><br><span class="line">        p1 = p1-&gt;next;</span><br><span class="line">        p2 = p2-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    p2 = p1-&gt;next;</span><br><span class="line">    p1-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> mergeTwoLists(sortList(head), sortList(p2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">ListNode *<span class="title">mergeTwoLists</span><span class="params">(ListNode* head1, ListNode* head2)</span></span>&#123;</span><br><span class="line">    ListNode *p1 = head1,  *p2=head2;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> ListNode <span class="title">dummy</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    ListNode *tail = &amp;dummy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p1 &amp;&amp; p2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p1-&gt;val &lt; p2-&gt;val)&#123;</span><br><span class="line">            tail-&gt;next = p1;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            tail-&gt;next = p2;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = tail-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p1) tail-&gt;next = p1;</span><br><span class="line">    <span class="keyword">if</span> (p2) tail-&gt;next = p2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-选择排序"><a href="#6-选择排序" class="headerlink" title="6. 选择排序"></a>6. 选择排序</h2><p>In computer science, selection sort is a sorting algorithm, specifically an in-place comparison sort. It has O(n^2) time complexity, making it inefficient on large lists, and generally performs worse than the similar insertion sort. Selection sort is noted for its simplicity, and it has performance advantages over more complicated algorithms in certain situations, particularly where auxiliary memory is limited.</p>
<p>The algorithm divides the input list into two parts: the sublist of items already sorted, which is built up from left to right at the front (left) of the list, and the sublist of items remaining to be sorted that occupy the rest of the list. Initially, the sorted sublist is empty and the unsorted sublist is the entire input list. The algorithm proceeds by finding the smallest (or largest, depending on sorting order) element in the unsorted sublist, exchanging (swapping) it with the leftmost unsorted element (putting it in sorted order), and moving the sublist boundaries one element to the right.</p>
<h3 id="6-1-实现"><a href="#6-1-实现" class="headerlink" title="6.1 实现"></a>6.1 实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* a[0] to a[n-1] is the array to sort */</span></span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* advance the position through the entire array */</span></span><br><span class="line"><span class="comment">/*   (could do j &lt; n-1 because single element is also min element) */</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n<span class="number">-1</span>; j++) &#123;</span><br><span class="line">    <span class="comment">/* find the min element in the unsorted a[j .. n-1] */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* assume the min is the first element */</span></span><br><span class="line">    <span class="keyword">int</span> iMin = j;</span><br><span class="line">    <span class="comment">/* test against elements after j to find the smallest */</span></span><br><span class="line">    <span class="keyword">for</span> ( i = j+<span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">/* if this element is less, then it is the new minimum */</span></span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; a[iMin]) &#123;</span><br><span class="line">            <span class="comment">/* found new minimum; remember its index */</span></span><br><span class="line">            iMin = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(iMin != j) &#123;</span><br><span class="line">        swap(a[j], a[iMin]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-2-分析"><a href="#6-2-分析" class="headerlink" title="6.2 分析"></a>6.2 分析</h3><p>Selection sort is not difficult to analyze compared to other sorting algorithms since none of the loops depend on the data in the array. Selecting the lowest element requires scanning all n elements (this takes n − 1 comparisons) and then swapping it into the first position. Finding the next lowest element requires scanning the remaining n − 1 elements and so on, for (n − 1) + (n − 2) + … + 2 + 1 = n(n - 1) / 2 ∈ Θ(n^2) comparisons (see arithmetic progression).[1] Each of these scans requires one swap for n − 1 elements (the final element is already in place).</p>
<h3 id="6-3-选择排序演示"><a href="#6-3-选择排序演示" class="headerlink" title="6.3 选择排序演示"></a>6.3 选择排序演示</h3><p><img src="https://upload.wikimedia.org/wikipedia/commons/9/94/Selection-Sort-Animation.gif" alt="image"><br>Selection sort animation. Red is current min. Yellow is sorted list. Blue is current item.</p>
<h2 id="7-堆排序"><a href="#7-堆排序" class="headerlink" title="7. 堆排序"></a>7. 堆排序</h2><p>In computer science, heapsort is a comparison-based sorting algorithm. Heapsort can be thought of as an improved selection sort: like that algorithm, it divides its input into a sorted and an unsorted region, and it iteratively shrinks the unsorted region by extracting the largest element and moving that to the sorted region. The improvement consists of the use of a heap data structure rather than a linear-time search to find the maximum.</p>
<p>Although somewhat slower in practice on most machines than a well-implemented quicksort, it has the advantage of a more favorable worst-case O(n log n) runtime. <strong>Heapsort is an in-place algorithm, but it is not a stable sort.</strong></p>
<p>The heapsort algorithm can be divided into two parts.</p>
<p>In the first step, a heap is built out of the data. The heap is often placed in an array with the layout of a complete binary tree. The complete binary tree maps the binary tree structure into the array indices; each array index represents a node; the index of the node’s parent, left child branch, or right child branch are simple expressions. For a zero-based array, the root node is stored at index 0; if i is the index of the current node, then</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iParent(i)     = floor((i-1) / 2)</span><br><span class="line">iLeftChild(i)  = 2*i + 1</span><br><span class="line">iRightChild(i) = 2*i + 2</span><br></pre></td></tr></table></figure>

<p>In the second step, a sorted array is created by repeatedly removing the largest element from the heap (the root of the heap), and inserting it into the array. The heap is updated after each removal to maintain the heap. Once all objects have been removed from the heap, the result is a sorted array.</p>
<p>Heapsort can be performed in place. The array can be split into two parts, the sorted array and the heap. The storage of heaps as arrays is diagrammed here. The heap’s invariant is preserved after each extraction, so the only cost is that of extraction.</p>
<h3 id="7-1-实现"><a href="#7-1-实现" class="headerlink" title="7.1 实现"></a>7.1 实现</h3><p><strong>(参考算法导论第3版堆排序一章并有所修改)</strong></p>
<p>二叉堆有两种，最大堆和最小堆（小根堆）。在最大堆中，最大堆的特性是指除了根以外的每个节点<code>i</code>，有<code>A[PARENT(i)] &gt;= A[i]</code>，这样在最大堆中最大的元素在树的根部。最小堆则相反，最小堆的特性是除了根节点以外的每个节点<code>i</code>，有<code>A[PARENT(i)] &lt;= A[i]</code>，这样在最小堆中最小的元素在树的根部。</p>
<p>堆排序的过程：  </p>
<ul>
<li><code>buildMaxHeap()</code>过程，以O(n)时间运行，可以在无序的输入数组基础上构建出最大堆。</li>
<li>交换数组中的第一个元素和最后一个元素，数组中的最大元素被移动到了它的最终位置，待排序的数组长度减少了1.</li>
<li>调用<code>maxHeapify()</code>过程，保持最大堆的性质，使最大的元素在堆的根部，此步骤的时间复杂度是O(log(n))。</li>
<li>重复步骤2直到未排序的数组中的元素个数减少到1。</li>
</ul>
<p>算法的伪代码如下：</p>
<p><code>maxHeapify()</code>是用于维护堆的性质，它的输入为一个数组<code>A</code>和一个下标<code>i</code>，在调用<code>maxHeapify()</code>的时候，我们假定根节点为<code>iLeftChild(i)</code>和<code>iRightChild(i)</code>的二叉树都是最大堆，但这时<code>A[i]</code>有可能小于其孩子，这样就违背了最大堆的性质。<code>maxHeapify()</code>通过让<code>A[i]</code>的值在最大堆中“逐级下降”，从而使得以下标<code>i</code>为根节点的子树重新遵循最大堆的性质。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">maxHeapify(A, i) &#123;</span><br><span class="line">    left = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    right = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> left &lt; A.heap_size <span class="keyword">and</span> A[left] &gt; A[i]</span><br><span class="line">        largest = left;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        largest = i;</span><br><span class="line">    <span class="keyword">if</span> right &lt; A.heap_size <span class="keyword">and</span> A[right] &gt; A[largest]</span><br><span class="line">        largest = right;</span><br><span class="line">    <span class="keyword">if</span> largest != i &#123;</span><br><span class="line">        exchange A[i] with A[largest];</span><br><span class="line">        maxHeapify(A, largest);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于一棵以<code>i</code>为根节点，大小为n的子树，<code>maxHeapify()</code>的时间代价包括：调整<code>A[i]</code>和<code>A[iLeftChild(i)]</code>和<code>A[iRightChild(i)]</code>的关系的时间代价Θ(1),加上在一棵以<code>i</code>的一个孩子为根节点的子树上运行<code>maxHeapify()</code>的时间代价（这里假设递归调用会发生）。因为每个孩子的子树的大小至多为2n/3（最坏情况发生在树的最底层恰好半满的时候），可以用下面的递归式表达运行时间：<br>$T(n) \leq T(2n/3)+\Theta(1)$<br>根据主定理，上述递归式的解为O(logn)。</p>
<p>假设数组的长度为n，则子数组<code>A[(n-1-1)/2+1...n-1]</code>中的元素都是树的叶子节点，每个叶子节点都可以看成只包含一个元素的堆。过程<code>buildMaxHeap()</code>对树中的其他节点都调用一次<code>maxHeapify()</code>。这是一个自底向上的建堆过程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">buildMaxHeap(A) &#123;</span><br><span class="line">    A.heap_size = A.length;</span><br><span class="line">    <span class="keyword">for</span> i = <span class="built_in">floor</span>((A.length - <span class="number">2</span>) / <span class="number">2</span>) downto <span class="number">0</span></span><br><span class="line">        maxHeapify(A, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>堆排序算法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">heapSort(A) &#123;</span><br><span class="line">    buildMaxHeap(A)</span><br><span class="line">    <span class="keyword">for</span> i = A.length - <span class="number">1</span> downto <span class="number">1</span> &#123;</span><br><span class="line">        exchange A[<span class="number">0</span>] with A[i]</span><br><span class="line">        A.heap_size = A.heap_size - <span class="number">1</span></span><br><span class="line">        maxHeapify(A, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-2-和其他排序算法的比较-Comparison-with-other-sorts"><a href="#7-2-和其他排序算法的比较-Comparison-with-other-sorts" class="headerlink" title="7.2 和其他排序算法的比较(Comparison with other sorts)"></a>7.2 和其他排序算法的比较(<a href="https://en.wikipedia.org/wiki/Heapsort#Comparison_with_other_sorts" target="_blank" rel="noopener">Comparison with other sorts</a>)</h3><p>Heapsort primarily competes with quicksort, another very efficient general purpose nearly-in-place comparison-based sort algorithm.</p>
<p>Quicksort is typically somewhat faster due to some factors, but the worst-case running time for quicksort is O(n^2), which is unacceptable for large data sets and can be deliberately triggered given enough knowledge of the implementation, creating a security risk. See quicksort for a detailed discussion of this problem and possible solutions.</p>
<p>Thus, because of the O(n log n) upper bound on heapsort’s running time and constant upper bound on its auxiliary storage, embedded systems with real-time constraints or systems concerned with security often use heapsort.</p>
<p>Heapsort also competes with merge sort, which has the same time bounds. Merge sort requires Ω(n) auxiliary space, but heapsort requires only a constant amount. Heapsort typically runs faster in practice on machines with small or slow data caches, and does not require as much external memory. On the other hand, merge sort has several advantages over heapsort:</p>
<ul>
<li>Merge sort on arrays has considerably better data cache performance, often outperforming heapsort on modern desktop computers because merge sort frequently accesses contiguous memory locations (good locality of reference); heapsort references are spread throughout the heap.</li>
<li>Heapsort is not a stable sort; merge sort is stable.</li>
<li>Merge sort parallelizes well and can achieve close to linear speedup with a trivial implementation; heapsort is not an obvious candidate for a parallel algorithm.</li>
<li>Merge sort can be adapted to operate on singly linked lists with O(1) extra space. Heapsort can be adapted to operate on doubly linked lists with only O(1) extra space overhead.</li>
<li>Merge sort is used in external sorting; heapsort is not. Locality of reference is the issue.</li>
</ul>
<p><a href="https://en.wikipedia.org/wiki/Introsort" target="_blank" rel="noopener">Introsort</a> is an alternative to heapsort that combines quicksort and heapsort to retain advantages of both: worst case speed of heapsort and average speed of quicksort.</p>
<h3 id="7-3-算法复杂度分析"><a href="#7-3-算法复杂度分析" class="headerlink" title="7.3 算法复杂度分析"></a>7.3 算法复杂度分析</h3><table>
<thead>
<tr>
<th align="left">Data structure</th>
<th align="left">Array</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Best case performance</td>
<td align="left">O(n log n), Ω(n)</td>
</tr>
<tr>
<td align="left">Worst case performance</td>
<td align="left">O(n log n)</td>
</tr>
<tr>
<td align="left">Average case performance</td>
<td align="left">O(n log n)</td>
</tr>
<tr>
<td align="left">Worst case space complexity</td>
<td align="left">O(1) auxiliary</td>
</tr>
</tbody></table>
<h3 id="7-4-堆排序演示"><a href="#7-4-堆排序演示" class="headerlink" title="7.4 堆排序演示"></a>7.4 堆排序演示</h3><p><img src="https://upload.wikimedia.org/wikipedia/commons/4/4d/Heapsort-example.gif" alt="image"></p>
<h3 id="7-5-堆排序的C-代码实现"><a href="#7-5-堆排序的C-代码实现" class="headerlink" title="7.5 堆排序的C++代码实现"></a>7.5 堆排序的C++代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        buildMaxHeap(A, n); </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="built_in">std</span>::swap(A[<span class="number">0</span>], A[i]);</span><br><span class="line">            heap_size--;</span><br><span class="line">            maxHeapify(A, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">maxHeapify</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> left = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">int</span> right = <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line">    	<span class="keyword">int</span> largest = <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">if</span>(left &lt; heap_size &amp;&amp; A[left] &gt; A[index]) &#123;</span><br><span class="line">            largest = left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            largest = index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right &lt; heap_size &amp;&amp; A[right] &gt; A[largest])</span><br><span class="line">            largest = right;</span><br><span class="line">        <span class="keyword">if</span>(largest != index) &#123;</span><br><span class="line">        	<span class="built_in">std</span>::swap(A[index], A[largest]);</span><br><span class="line">        	maxHeapify(A, largest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    	heap_size = n;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = (n - <span class="number">2</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            maxHeapify(A, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> heap_size = <span class="number">0</span>;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[] = &#123;<span class="number">9</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">19</span>, <span class="number">8</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    HeapSort h;</span><br><span class="line">    h.heapSort(A, n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> e : A) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="string">"  "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Reference Links：<br><a href="http://blog.csdn.net/xiazdong/article/details/8462393" target="_blank" rel="noopener">九大排序算法再总结</a><br><a href="http://blog.csdn.net/amazing7/article/details/51603682" target="_blank" rel="noopener">九大基础排序总结与对比</a><br><a href="http://blog.csdn.net/xiazdong/article/details/7304239" target="_blank" rel="noopener">数据结构复习之【排序】</a><br><a href="http://blog.csdn.net/hguisu/article/details/7776068" target="_blank" rel="noopener">八大排序算法</a><br><a href="https://en.wikipedia.org/wiki/Sorting_algorithm" target="_blank" rel="noopener">Sorting algorithm</a><br><a href="http://www.cs.wcupa.edu/rkline/ds/shell-comparison.html" target="_blank" rel="noopener">希尔排序</a>  </p>
<p>排序算法视频演示：<br><a href="http://www.bilibili.com/video/av685670/" target="_blank" rel="noopener">http://www.bilibili.com/video/av685670/</a><br><a href="http://airtucha.github.io/SortVis/" target="_blank" rel="noopener">http://airtucha.github.io/SortVis/</a></p>
</div><div class="tags"><a href="/tags/Algorithm/">Algorithm</a></div><div class="post-nav"><a class="pre" href="/2017/03/20/Hexo博客建站流程备忘/">Hexo博客建站流程备忘</a><a class="next" href="/2016/07/10/刷编程竞赛类题目的一些小技巧/">刷编程竞赛类题目的一些小技巧</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://evanqiao.github.io/2016/08/25/典型排序算法回顾/';
    this.page.identifier = '2016/08/25/典型排序算法回顾/';
    this.page.title = '典型排序算法回顾';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//xiaojn.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//xiaojn.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://xiaojn.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://evanqiao.github.io"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Tools/">Tools</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/博客建设/">博客建设</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/我学编程/">我学编程</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/文清说/">文清说</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程语言/">编程语言</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/闲情记趣/">闲情记趣</a><span class="category-list-count">2</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/C/" style="font-size: 15px;">C++</a> <a href="/tags/Algorithm/" style="font-size: 15px;">Algorithm</a> <a href="/tags/MarkDown/" style="font-size: 15px;">MarkDown</a> <a href="/tags/Raspberry/" style="font-size: 15px;">Raspberry</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/May/" style="font-size: 15px;">May</a> <a href="/tags/vim/" style="font-size: 15px;">vim</a> <a href="/tags/Mathematics/" style="font-size: 15px;">Mathematics</a> <a href="/tags/free/" style="font-size: 15px;">free</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/07/06/快乐/">快乐</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/04/搬家/">搬家</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/30/NOIP2013_2表达式求值/">NOIP2013表达式求值</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/30/NOIP2012_02寻宝/">NOIP2012寻宝</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/05/斜挎包的聚会/">跨斜包的聚会</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/04/Practical_backTracking/">实践回溯法</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/21/heap_priority_queue/">堆和优先队列的算法应用</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/14/The_first_one/">The First One</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/14/来玩一下超声波测距/">来玩一下超声波测距</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/14/Practical_binaryTree/">初探二叉树的应用</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//xiaojn.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://www.haomwei.com/" title="屠夫9441的博客" target="_blank">屠夫9441的博客</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">晓江南的博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>